<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>COSMIC CHAOS: UFO DESTROYER</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Courier New', monospace;
            color: #0ff;
            background-color: #000;
            touch-action: none; /* Prevent browser default touch behaviors */
        }
        canvas {
            display: block;
        }
        #ui-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }
        #hud {
            position: absolute;
            top: 20px;
            left: 20px;
            padding: 15px;
            background-color: rgba(0, 0, 0, 0.5);
            border: 1px solid #0ff;
            border-radius: 10px;
        }
        #boost-meter {
            position: absolute;
            top: 150px;
            left: 20px;
            width: 150px;
            height: 20px;
            background-color: rgba(0, 0, 0, 0.5);
            border: 1px solid #0ff;
            border-radius: 10px;
            overflow: hidden;
        }
        #boost-meter-fill {
            height: 100%;
            width: 100%;
            background-color: #0ff;
            transform-origin: left;
            transform: scaleX(1);
            transition: transform 0.3s;
        }
        #minimap {
            position: absolute;
            top: 20px;
            right: 180px;
            width: 200px;
            height: 200px;
            background-color: rgba(0, 0, 0, 0.5);
            border: 1px solid #0ff;
            border-radius: 50%;
            overflow: hidden;
        }
        #minimap-dots {
            position: relative;
            width: 100%;
            height: 100%;
        }
        .minimap-dot {
            position: absolute;
            width: 4px;
            height: 4px;
            background-color: #0ff;
            border-radius: 50%;
            transform: translate(-50%, -50%);
        }
        .minimap-dot.player {
            width: 6px;
            height: 6px;
            background-color: #ff0;
        }
        #targeting {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 100px;
            height: 100px;
        }
        #targeting-inner {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            border: 2px solid #0ff;
            border-radius: 50%;
        }
        #targeting-outer {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 80px;
            height: 80px;
            border: 1px solid #0ff;
            border-radius: 50%;
        }
        #targeting-lines {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 100px;
            height: 100px;
        }
        .targeting-line {
            position: absolute;
            background-color: #0ff;
        }
        .horizontal {
            width: 100%;
            height: 1px;
            top: 50%;
        }
        .vertical {
            height: 100%;
            width: 1px;
            left: 50%;
        }
        #instructions {
            position: absolute;
            bottom: 20px;
            left: 20px;
            padding: 15px;
            background-color: rgba(0, 0, 0, 0.5);
            border: 1px solid #0ff;
            border-radius: 10px;
            max-width: 400px;
        }
        #alien-symbols {
            position: absolute;
            top: 20px;
            right: 20px;
            padding: 15px;
            background-color: rgba(0, 0, 0, 0.5);
            border: 1px solid #0ff;
            border-radius: 10px;
            font-family: 'Symbol', 'Webdings', monospace;
            font-size: 20px;
            letter-spacing: 5px;
        }
        #planet-info {
            position: absolute;
            bottom: 20px;
            right: 20px;
            padding: 15px;
            background-color: rgba(0, 0, 0, 0.5);
            border: 1px solid #0ff;
            border-radius: 10px;
        }
        #loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: black;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 999;
        }
        #loading-bar-container {
            width: 50%;
            height: 30px;
            border: 2px solid #0ff;
            border-radius: 15px;
            margin-top: 20px;
        }
        #loading-bar {
            width: 0%;
            height: 100%;
            background-color: #0ff;
            border-radius: 15px;
            transition: width 0.5s;
        }
        #game-title {
            font-size: 48px;
            margin-bottom: 20px;
            letter-spacing: 5px;
            text-shadow: 0 0 10px #0ff;
        }
        .blink {
            animation: blink 1s infinite;
        }
        @keyframes blink {
            0% { opacity: 1; }
            50% { opacity: 0.3; }
            100% { opacity: 1; }
        }
        @keyframes portalPulse {
            0% { transform: scale(1) rotate(0deg); box-shadow: 0 0 10px #00ff00; }
            50% { transform: scale(1.2) rotate(180deg); box-shadow: 0 0 15px #00ff00; }
            100% { transform: scale(1) rotate(360deg); box-shadow: 0 0 10px #00ff00; }
        }
        #destruction-rating {
            position: absolute;
            top: 50%;
            right: 20px;
            padding: 15px;
            background-color: rgba(0, 0, 0, 0.5);
            border: 1px solid #f00;
            border-radius: 10px;
            color: #f00;
            display: none;
        }
        #explosion-flash {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(255, 100, 0, 0);
            pointer-events: none;
            transition: background-color 0.1s;
            z-index: 100;
        }
        #tutorial {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            padding: 20px;
            background-color: rgba(0, 0, 0, 0.8);
            border: 1px solid #0ff;
            border-radius: 10px;
            width: 60%;
            max-width: 800px;
            max-height: 80vh; /* Limit height on all devices */
            overflow-y: auto; /* Enable scrolling */
            z-index: 500;
        }
        #tutorial h2 {
            text-align: center;
            color: #0ff;
            font-size: 24px;
            margin-top: 0;
        }
        #tutorial ul {
            margin-left: 20px;
            padding-right: 10px;
        }
        #tutorial-close {
            display: block;
            margin: 20px auto 0;
            padding: 15px 30px;
            background-color: rgba(0, 255, 255, 0.3);
            color: #0ff;
            border: 1px solid #0ff;
            border-radius: 5px;
            cursor: pointer;
            pointer-events: auto;
            font-size: 18px;
            font-weight: bold;
            position: sticky;
            bottom: 0;
            width: 80%;
        }
        #tutorial-close:hover {
            background-color: rgba(0, 255, 255, 0.5);
        }
        /* Mobile-specific styles */
        @media (max-width: 768px) {
            #tutorial {
                width: 85%;
                max-height: 70vh;
                padding: 15px;
            }
            #tutorial h2 {
                font-size: 20px;
                margin-bottom: 10px;
            }
            #tutorial ul {
                margin-left: 10px;
                font-size: 14px;
            }
            #tutorial li {
                margin-bottom: 8px;
            }
            #tutorial-close {
                padding: 15px 0;
                margin: 15px auto 5px;
                font-size: 16px;
                width: 100%;
            }
        }
        /* Small mobile screens */
        @media (max-width: 480px) {
            #tutorial {
                width: 90%;
                max-height: 60vh;
                padding: 10px;
            }
            #tutorial h2 {
                font-size: 18px;
            }
            #tutorial ul {
                padding-left: 20px;
                margin-left: 0;
            }
            #tutorial-close {
                margin-bottom: 0;
                position: fixed;
                bottom: 20px;
                left: 50%;
                transform: translateX(-50%);
                width: 80%;
                z-index: 501;
            }
        }
        /* Tutorial header styles */
        .tutorial-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            position: sticky;
            top: 0;
            background-color: rgba(0, 0, 0, 0.9);
            padding-bottom: 10px;
            z-index: 10;
        }
        .tutorial-x {
            background-color: rgba(255, 0, 0, 0.4);
            color: white;
            border: 1px solid #ff4444;
            border-radius: 50%;
            width: 32px;
            height: 32px;
            font-size: 18px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            padding: 0;
        }
        .tutorial-x:hover {
            background-color: rgba(255, 0, 0, 0.6);
        }
        .hidden {
            display: none !important;
        }
        #orientation-indicator {
            position: absolute;
            bottom: 180px;
            left: 20px;
            width: 100px;
            height: 100px;
            background-color: rgba(0, 0, 0, 0.5);
            border: 1px solid #0ff;
            border-radius: 10px;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        #orientation-dot {
            width: 8px;
            height: 8px;
            background-color: #ff0;
            border-radius: 50%;
            position: absolute;
            transition: transform 0.1s;
        }
        #orientation-center {
            width: 4px;
            height: 4px;
            background-color: #0ff;
            border-radius: 50%;
            position: absolute;
        }
        #orientation-h-line {
            width: 90%;
            height: 1px;
            background-color: #0ff;
            position: absolute;
        }
        #orientation-v-line {
            width: 1px;
            height: 90%;
            background-color: #0ff;
            position: absolute;
        }
        #message-box {
            position: absolute;
            top: 40%;
            left: 50%;
            transform: translate(-50%, -50%);
            padding: 15px 30px;
            background-color: rgba(0, 0, 0, 0.7);
            border: 1px solid #0ff;
            border-radius: 10px;
            font-size: 24px;
            font-weight: bold;
            text-align: center;
            color: #0ff;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
            z-index: 200;
        }
        #chat-container {
            position: absolute;
            bottom: 400px !important; /* Move higher up */
            right: 20px !important; /* Move to right side */
            left: auto !important; /* Override any left positioning */
            width: 300px;
            background-color: rgba(0, 0, 0, 0.5);
            border: 1px solid #0ff;
            border-radius: 10px;
            padding: 10px;
            display: flex;
            flex-direction: column;
            z-index: 110 !important; /* Highest z-index */
            max-height: 200px; /* Limit height */
            overflow: hidden;
        }
        #active-players {
            position: absolute;
            bottom: 250px !important; /* Position between chat and planet info */
            right: 20px !important;
            width: 300px;
            background-color: rgba(0, 0, 0, 0.5);
            border: 1px solid #0ff;
            border-radius: 10px;
            padding: 10px;
            color: #0ff;
            z-index: 105 !important; /* Middle z-index */
            max-height: 150px;
            overflow-y: auto;
        }
        #planet-info {
            position: absolute;
            bottom: 20px !important; /* Keep at bottom */
            right: 20px !important;
            padding: 15px;
            background-color: rgba(0, 0, 0, 0.5);
            border: 1px solid #0ff;
            border-radius: 10px;
            z-index: 100 !important; /* Lowest z-index */
        }
        #chat-messages {
            max-height: 150px;
            overflow-y: auto;
            margin-bottom: 10px;
            color: #0ff;
        }
        #chat-input {
            flex: 1;
            padding: 5px;
            background-color: rgba(0, 0, 0, 0.3);
            border: 1px solid #0ff;
            border-radius: 5px;
            color: #0ff;
            outline: none;
        }
        #chat-form button {
            margin-left: 5px;
            padding: 5px 10px;
            background-color: rgba(0, 255, 255, 0.2);
            border: 1px solid #0ff;
            border-radius: 5px;
            color: #0ff;
            cursor: pointer;
        }
        /* Widget minimize/expand functionality */
        .widget {
            position: relative;
            transition: all 0.3s ease;
            overflow: hidden;
        }
        
        .widget-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            padding: 5px;
            margin: -5px -5px 5px -5px;
            border-bottom: 1px solid rgba(0, 255, 255, 0.3);
        }
        
        .widget-title {
            font-weight: bold;
            margin: 0;
        }
        
        .widget-toggle {
            background: none;
            border: none;
            color: #0ff;
            font-size: 16px;
            cursor: pointer;
            padding: 0 5px;
            margin-left: 5px;
            transition: transform 0.3s;
        }
        
        .widget-toggle:hover {
            color: #fff;
        }
        
        .widget-content {
            transition: max-height 0.3s ease;
            max-height: 1000px; /* Large enough to contain content */
            overflow: hidden;
        }
        
        .widget.minimized .widget-content {
            max-height: 0;
        }
        
        .widget.minimized .widget-toggle {
            transform: rotate(180deg);
        }
        
        /* Toggle all button for mobile */
        #toggle-all-widgets {
            position: fixed;
            top: 10px;
            right: 10px;
            background-color: rgba(0, 0, 0, 0.7);
            color: #0ff;
            border: 1px solid #0ff;
            border-radius: 5px;
            padding: 8px 12px;
            font-size: 16px;
            z-index: 600;
            cursor: pointer;
            pointer-events: auto;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        
        #toggle-all-widgets:hover {
            background-color: rgba(0, 255, 255, 0.2);
        }
        
        /* Make toggle button more visible on mobile */
        @media (max-width: 768px) {
            #toggle-all-widgets {
                font-size: 24px;
                padding: 12px 16px;
                background-color: rgba(0, 0, 0, 0.8);
                border: 2px solid #0ff;
                box-shadow: 0 0 8px #0ff;
                top: 15px;
                right: 15px;
            }
            
            /* Hide text on mobile, show only icon */
            #toggle-all-widgets .toggle-text {
                display: none;
            }
        }
        
        /* Mobile-specific adjustments for widgets */
        @media (max-width: 768px) {
            .widget {
                max-width: 95vw;
                background-color: rgba(0, 0, 0, 0.7); /* Darker background on mobile */
            }
            
            .widget-header {
                padding: 10px;
                background-color: rgba(0, 0, 0, 0.8);
                border-radius: 5px;
            }
            
            .widget-toggle {
                font-size: 22px;
                padding: 0 8px;
                width: 40px;
                height: 30px;
                line-height: 30px;
                text-align: center;
            }
            
            /* Adjust specific widget positions on mobile */
            #hud {
                top: 10px;
                left: 10px;
                right: auto;
                width: auto;
                max-width: 70vw;
            }
            
            #planet-info {
                bottom: 10px !important;
                right: 10px !important;
                width: auto;
                max-width: 80vw;
            }
            
            #instructions {
                bottom: 10px;
                left: 10px;
                max-width: 80vw;
            }
            
            /* Default to minimized state for some widgets on mobile */
            #instructions.auto-minimize {
                max-height: 45px;
            }
        }
    </style>
</head>
<body>
    <div id="loading-screen">
        <div id="game-title">COSMIC CHAOS: UFO DESTROYER</div>
        <div class="blink">LOADING INTERGALACTIC SYSTEMS...</div>
        <div id="loading-bar-container">
            <div id="loading-bar"></div>
        </div>
    </div>

    <div id="explosion-flash"></div>

    <div id="ui-container">
        <button id="toggle-all-widgets" onclick="toggleAllWidgets()"><span class="toggle-icon">üîΩ</span><span class="toggle-text">ALL WIDGETS</span></button>
        <div id="hud" class="widget">
            <div class="widget-header">
                <div class="widget-title">SHIP STATS</div>
                <button class="widget-toggle" onclick="toggleWidget('hud')">‚ñº</button>
            </div>
            <div class="widget-content">
                <div>Speed: <span id="speed">0.0</span> units/s</div>
                <div>Shields: <span id="shields">100</span>%</div>
                <div>Bombs: <span id="bombs">3</span></div>
                <div>Planets Destroyed: <span id="destroyed">0</span></div>
                <div>Resources: <span id="resources">0</span></div>
                <div>Coordinates: <span id="coordinates">0,0,0</span></div>
                <div>Sector: <span id="sector">ALPHA-1</span></div>
                <div>Score: <span id="score">0</span></div>
            </div>
        </div>
        
        <div id="boost-meter">
            <div id="boost-meter-fill"></div>
        </div>
        
        <div id="minimap">
            <div id="minimap-dots"></div>
        </div>
        
        <div id="targeting">
            <div id="targeting-inner"></div>
            <div id="targeting-outer"></div>
            <div id="targeting-lines">
                <div class="targeting-line horizontal"></div>
                <div class="targeting-line vertical"></div>
            </div>
        </div>
        
        <div id="instructions" class="widget">
            <div class="widget-header">
                <div class="widget-title">CONTROLS</div>
                <button class="widget-toggle" onclick="toggleWidget('instructions')">‚ñº</button>
            </div>
            <div class="widget-content">
                <h3>UFO CONTROLS:</h3>
                <div>WASD: MOVE UFO</div>
                <div>MOUSE: STEER UFO</div>
                <div>SHIFT: BOOST (Watch fuel meter!)</div>
                <div>SPACE: TRACTOR BEAM</div>
                <div>L: LAND NEAR PLANET</div>
                
                <h3>ALIEN CONTROLS:</h3>
                <div>WASD: WALK</div>
                <div>MOUSE: LOOK</div>
                <div>B: CYCLE BOMB SIZE (1-3)</div>
                <div>P: PLACE BOMB</div>
                <div>E: RETURN TO SHIP</div>
                
                <h3>GENERAL:</h3>
                <div>ESC: TOGGLE TUTORIAL</div>
            </div>
        </div>
        
        <div id="alien-symbols">
            ‚®Å‚å¨‚è£‚éî‚è±‚å≠‚åñ‚åò‚å¨‚®Ç</div>
        
        <div id="planet-info" class="widget">
            <div class="widget-header">
                <div class="widget-title">PLANET SCANNER</div>
                <button class="widget-toggle" onclick="toggleWidget('planet-info')">‚ñº</button>
            </div>
            <div class="widget-content">
                <div>SCANNING...</div>
                <div>NEAREST PLANET: <span id="nearest-planet">NONE</span></div>
                <div>DISTANCE: <span id="planet-distance">‚àû</span> UNITS</div>
                <div>COMPOSITION: <span id="planet-composition">UNKNOWN</span></div>
                <div>STATUS: <span id="planet-status">INTACT</span></div>
            </div>
        </div>

        <div id="destruction-rating">
            <div>DESTRUCTION RATING</div>
            <div>PLANET: <span id="destroyed-planet">NONE</span></div>
            <div>EFFICIENCY: <span id="destruction-efficiency">0</span>%</div>
            <div>RESOURCES COLLECTED: <span id="resources-collected">0</span></div>
            <div>BONUS: <span id="destruction-bonus">NONE</span></div>
        </div>

        <div id="tutorial" class="hidden">
            <div class="tutorial-header">
                <h2>ALIEN PILOT MANUAL</h2>
                <button class="tutorial-x" onclick="hideTutorial()">‚úï</button>
            </div>
            <ul>
                <li>Your mission is to explore and destroy procedurally generated planets</li>
                <li>Navigate your UFO using WASD for movement and mouse for orientation</li>
                <li>Press SHIFT to activate your boost drive for faster travel</li>
                <li>Approach planets carefully - atmospheric entry causes turbulence</li>
                <li>When near a planet surface, press L to land your craft</li>
                <li>Your alien explorer will automatically deploy on landing</li>
                <li>Control your alien with WASD and look around with the mouse</li>
                <li>Press B to cycle through three different bomb sizes (1-3)</li>
                <li>Press P to place a bomb at your current location</li>
                <li>Return to your ship (press E when near) to escape before detonation</li>
                <li>Use your tractor beam (SPACE) to collect resources from debris</li>
                <li>Larger planets may contain valuable resources</li>
                <li>Look for wormholes to discover new sectors</li>
                <li>Different planet types offer unique exploration experiences</li>
            </ul>
            <button id="tutorial-close" onclick="hideTutorial()">CONTINUE MISSION</button>
        </div>
        
        <div id="orientation-indicator">
            <div id="orientation-h-line"></div>
            <div id="orientation-v-line"></div>
            <div id="orientation-center"></div>
            <div id="orientation-dot"></div>
        </div>
        
        <div id="message-box"></div>
        
        <div id="chat-container" style="display: none;">
            <div id="chat-messages"></div>
            <form id="chat-form">
                <input id="chat-input" type="text" placeholder="Type message..." />
                <button type="submit">Send</button>
            </form>
        </div>
        
        <div id="active-players">
            <!-- Will be populated with active players -->
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/simplex-noise/2.4.0/simplex-noise.min.js"></script>

    <script>
        // Game state
        const gameState = {
            playerShip: null,
            camera: null,
            planets: [],
            stars: [],
            bombs: [],
            particles: [],
            debris: [],
            explosions: [], // Add explosions array
            isAlienMode: false,
            alienModel: null,
            cameraTarget: null,
            alienMouseLook: { x: 0, y: 0 },
            flatGround: null,
            flatScene: null, // New scene for flat world exploration
            mainScene: null, // Reference to main scene for switching
            currentScene: null, // Current active scene
            landedOnPlanet: null,
            bombsRemaining: 3,
            bombSize: 1, // Current bomb size (1-3)
            planetsDestroyed: 0,
            shields: 100,
            speed: 0,
            maxSpeed: 3, // Increased from 2 for faster travel
            boostMultiplier: 6.0, // Increased from 5.0 for even faster boost
            isBoostActive: false,
            boostFuel: 100,
            maxBoostFuel: 100,
            boostRechargeRate: 15, // Increased from 10 for faster recharge
            boostDrainRate: 20, // Per second
            boostEffects: [],
            boostSound: null,
            isTractorBeamActive: false,
            nearestPlanet: null,
            nearestPlanetDistance: Infinity,
            wormholes: [],
            resourcesCollected: 0,
            isLoading: true,
            loadingProgress: 0,
            isTutorialVisible: false,
            universeSize: 200000, // Vastly expanded universe size (from 50000)
            minimapElements: [],
            playerSector: "ALPHA-1",
            minimapUpdateTimer: 0,
            minimapUpdateInterval: 1, // Update minimap every 1 second
            planetsManager: {
                minPlanetCount: 25, // Increased for more planets
                maxPlanetDistance: 50000, // Increased planet spawn distance (from 10000)
                checkInterval: 5, // Check more frequently (from 10)
                lastCheck: 0,
                planetsPerSector: 8, // Increased planets per sector (from 5)
                sectors: {}, // Will hold sector information
                sectorSize: 10000, // Explicitly define sector size (larger than before)
            },
            shipOrientation: {
                yaw: 0,
                pitch: 0
            },
            tractorBeamEffect: null,
            navigationAssist: true, // Enable navigation assistance by default
            currentVelocity: null, // Added for smoother deceleration
            activeMessages: [], // Track active message timeouts
            // Add multiplayer support
            multiplayer: {
                enabled: false,
                socket: null,
                playerId: null,
                playerColor: null,
                otherPlayers: new Map(),
                chatMessages: [],
                lastPositionUpdate: 0,
                updateInterval: 100, // ms between position updates
                lastServerMessage: 0, // Add this line
            },
            // Add alien communication functionality
            discoveredMessages: [
                { symbol: "‚®Å", meaning: "GREETINGS", discovered: false },
                { symbol: "‚å¨", meaning: "DANGER", discovered: false },
                { symbol: "‚è£", meaning: "RESOURCES", discovered: false },
                { symbol: "‚éî", meaning: "WORMHOLE", discovered: false },
                { symbol: "‚è±", meaning: "TIME", discovered: false },
                { symbol: "‚å≠", meaning: "WEAPON", discovered: false },
                { symbol: "‚åñ", meaning: "TARGET", discovered: false },
                { symbol: "‚åò", meaning: "COMMAND", discovered: false },
                { symbol: "‚®Ç", meaning: "FORBIDDEN", discovered: false }
            ]
        };

        // Input state
        const inputState = {
            moveForward: false,
            moveBackward: false,
            moveLeft: false,
            moveRight: false,
            moveUp: false,
            moveDown: false,
            boost: false,
            mouseX: 0,
            mouseY: 0
        };

        // Planet names
        const planetPrefixes = ['Zor', 'Xen', 'Qua', 'Vril', 'Nyx', 'Trag', 'Plex', 'Kron', 'Glib', 'Blip'];
        const planetSuffixes = ['zar', 'tron', 'plex', 'ton', 'thor', 'mor', 'gor', 'nox', 'lax', 'dox'];
        const planetMaterials = ['Rocky', 'Gaseous', 'Molten', 'Frozen', 'Toxic', 'Oceanic', 'Desert', 'Crystalline'];

        // Three.js setup
        let scene, renderer, clock;
        
        function initThreeJS() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000011);
            
            // Add fog for atmospheric effect - reduced density for larger viewing distance
            scene.fog = new THREE.FogExp2(0x000011, 0.00002); // Reduced fog density for longer view distance
            
            // Create camera with increased far plane for bigger universe
            const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 500000);
            gameState.camera = camera;
            
            // Create renderer with improved settings
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true; // Enable shadows
            document.body.appendChild(renderer.domElement);
            
            // Clock for timing
            clock = new THREE.Clock();
            
            // Handle window resize
            window.addEventListener('resize', () => {
                gameState.camera.aspect = window.innerWidth / window.innerHeight;
                gameState.camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }
        
        function initLighting() {
            // Ambient light
            const ambientLight = new THREE.AmbientLight(0x333344);
            scene.add(ambientLight);
            
            // Directional light (sun)
            const sunLight = new THREE.DirectionalLight(0xffffff, 1);
            sunLight.position.set(1000, 1000, 1000);
            scene.add(sunLight);
            
            // Add a point light to the player's ship for better visibility
            const shipLight = new THREE.PointLight(0x7777ff, 0.5, 50);
            shipLight.position.set(0, 0, 0);
            gameState.shipLight = shipLight;
        }
        
        function createStarfield() {
            const starGeometry = new THREE.BufferGeometry();
            const starMaterial = new THREE.PointsMaterial({
                color: 0xffffff,
                size: 1.5,
                sizeAttenuation: false
            });
            
            const starVertices = [];
            
            // Create stars - significantly increased count and distribution for larger universe
            for (let i = 0; i < 200000; i++) { // Increased from 50000
                const x = (Math.random() - 0.5) * gameState.universeSize;
                const y = (Math.random() - 0.5) * gameState.universeSize;
                const z = (Math.random() - 0.5) * gameState.universeSize;
                
                starVertices.push(x, y, z);
            }
            
            starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starVertices, 3));
            
            const stars = new THREE.Points(starGeometry, starMaterial);
            scene.add(stars);
            gameState.stars.push(stars);
            
            // Create distant nebulae for visual interest in the expanded universe
            createDistantNebulae();
        }
        
        function createDistantNebulae() {
            // Create several colorful nebulae in the distance
            const nebulaColors = [
                0x7b68ee, // Medium slate blue
                0x4b0082, // Indigo
                0x9932cc, // Dark orchid
                0x8a2be2, // Blue violet
                0x9400d3, // Dark violet
                0xff4500, // Orange-red
                0x00ced1, // Dark turquoise
                0xff1493  // Deep pink
            ];
            
            for (let i = 0; i < 20; i++) { // Increased from 8
                const nebulaSize = 10000 + Math.random() * 20000; // Larger nebulae
                const distance = gameState.universeSize * 0.4;
                const angle = Math.random() * Math.PI * 2;
                const elevation = (Math.random() - 0.5) * Math.PI;
                
                const x = Math.cos(angle) * Math.cos(elevation) * distance;
                const y = Math.sin(elevation) * distance;
                const z = Math.sin(angle) * Math.cos(elevation) * distance;
                
                const nebulaGeometry = new THREE.PlaneGeometry(nebulaSize, nebulaSize);
                const nebulaMaterial = new THREE.MeshBasicMaterial({
                    color: nebulaColors[Math.floor(Math.random() * nebulaColors.length)],
                    transparent: true,
                    opacity: 0.3,
                    side: THREE.DoubleSide,
                    depthWrite: false
                });
                
                const nebula = new THREE.Mesh(nebulaGeometry, nebulaMaterial);
                nebula.position.set(x, y, z);
                
                // Orient the nebula to face the center of the universe roughly
                nebula.lookAt(0, 0, 0);
                // Add some random rotation
                nebula.rotation.z = Math.random() * Math.PI * 2;
                
                scene.add(nebula);
            }
        }
        
        function createPlayerShip() {
            // Ship group
            const shipGroup = new THREE.Group();
            
            // UFO body
            const bodyGeometry = new THREE.SphereGeometry(1, 32, 32);
            bodyGeometry.scale(1, 0.4, 1);
            const bodyMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x888899,
                specular: 0x111111,
                shininess: 100
            });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            shipGroup.add(body);
            
            // Cockpit dome
            const domeGeometry = new THREE.SphereGeometry(0.5, 32, 16, 0, Math.PI * 2, 0, Math.PI / 2);
            const domeMaterial = new THREE.MeshPhongMaterial({
                color: 0x44aaff,
                specular: 0xffffff,
                shininess: 100,
                transparent: true,
                opacity: 0.9
            });
            const dome = new THREE.Mesh(domeGeometry, domeMaterial);
            dome.position.y = 0.2;
            shipGroup.add(dome);
            
            // Bottom ring
            const ringGeometry = new THREE.TorusGeometry(0.8, 0.1, 16, 32);
            const ringMaterial = new THREE.MeshPhongMaterial({
                color: 0xaaaaaa,
                specular: 0x666666,
                shininess: 30
            });
            const ring = new THREE.Mesh(ringGeometry, ringMaterial);
            ring.position.y = -0.15;
            ring.rotation.x = Math.PI / 2;
            shipGroup.add(ring);
            
            // Engine lights
            const engineLightGeometry = new THREE.CircleGeometry(0.1, 16);
            const engineLightMaterial = new THREE.MeshBasicMaterial({ color: 0x00ffff });
            
            for (let i = 0; i < 3; i++) {
                const angle = (i / 3) * Math.PI * 2;
                const engineLight = new THREE.Mesh(engineLightGeometry, engineLightMaterial);
                engineLight.position.set(
                    Math.cos(angle) * 0.8,
                    -0.25,
                    Math.sin(angle) * 0.8
                );
                engineLight.rotation.x = -Math.PI / 2;
                shipGroup.add(engineLight);
            }
            
            // Add the ship light to the ship
            shipGroup.add(gameState.shipLight);
            
            // Set initial position
            shipGroup.position.set(0, 100, 0);
            
            // Initialize ship orientation tracking for consistent controls
            gameState.shipOrientation = {
                yaw: 0,
                pitch: 0
            };
            
            // Add ship to scene
            scene.add(shipGroup);
            gameState.playerShip = shipGroup;
            
            // Set initial camera position relative to ship
            gameState.camera.position.set(0, 3, 10);
            shipGroup.add(gameState.camera);
        }
        
        function createAlienModel() {
            // Create a simple alien model
            const alienGroup = new THREE.Group();
            
            // Head
            const headGeometry = new THREE.SphereGeometry(0.2, 16, 16);
            headGeometry.scale(0.8, 1.2, 1);
            const headMaterial = new THREE.MeshLambertMaterial({ color: 0xcccccc });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.y = 0.6;
            alienGroup.add(head);
            
            // Eyes
            const eyeGeometry = new THREE.SphereGeometry(0.06, 8, 8);
            const eyeMaterial = new THREE.MeshBasicMaterial({ color: 0x000000 });
            
            const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            leftEye.position.set(-0.1, 0.65, 0.15);
            alienGroup.add(leftEye);
            
            const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            rightEye.position.set(0.1, 0.65, 0.15);
            alienGroup.add(rightEye);
            
            // Body
            const bodyGeometry = new THREE.CylinderGeometry(0.15, 0.1, 0.4, 16);
            const bodyMaterial = new THREE.MeshLambertMaterial({ color: 0xcccccc });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = 0.3;
            alienGroup.add(body);
            
            // Arms
            const armGeometry = new THREE.CylinderGeometry(0.03, 0.03, 0.25, 8);
            const armMaterial = new THREE.MeshLambertMaterial({ color: 0xcccccc });
            
            const leftArm = new THREE.Mesh(armGeometry, armMaterial);
            leftArm.position.set(-0.2, 0.3, 0);
            leftArm.rotation.z = Math.PI / 4;
            alienGroup.add(leftArm);
            
            const rightArm = new THREE.Mesh(armGeometry, armMaterial);
            rightArm.position.set(0.2, 0.3, 0);
            rightArm.rotation.z = -Math.PI / 4;
            alienGroup.add(rightArm);
            
            // Legs
            const legGeometry = new THREE.CylinderGeometry(0.03, 0.03, 0.3, 8);
            const legMaterial = new THREE.MeshLambertMaterial({ color: 0xcccccc });
            
            const leftLeg = new THREE.Mesh(legGeometry, legMaterial);
            leftLeg.position.set(-0.07, 0.05, 0);
            alienGroup.add(leftLeg);
            
            const rightLeg = new THREE.Mesh(legGeometry, legMaterial);
            rightLeg.position.set(0.07, 0.05, 0);
            alienGroup.add(rightLeg);
            
            // Add a small light to see in the dark
            const alienLight = new THREE.PointLight(0x88aaff, 0.7, 10);
            alienLight.position.set(0, 0.5, 0);
            alienGroup.add(alienLight);
            
            // Hide initially
            alienGroup.visible = false;
            scene.add(alienGroup);
            gameState.alienModel = alienGroup;
        }
        
        function createPlanet(position, size = 50, type = getRandomPlanetMaterial()) {
            // Create the planet
            const planetGroup = new THREE.Group();
            planetGroup.position.copy(position);
            
            // Generate planet properties
            const planetName = getRandomPlanetName();
            const planetSize = size;
            const planetRotationSpeed = Math.random() * 0.001 - 0.0005;
            
            // Add an ID to the planet
            const planetId = 'planet-' + Math.random().toString(36).substr(2, 9);
            
            // Create geometry and material based on planet type
            let planetGeometry, planetMaterial;
            
            // Create a noise function for terrain
            const simplex = new SimplexNoise();
            
            planetGeometry = new THREE.SphereGeometry(planetSize, 64, 64);
            
            // Create different materials based on type
            let planetColor;
            
            switch (type) {
                case 'Rocky':
                    planetColor = new THREE.Color(
                        0.5 + Math.random() * 0.2,
                        0.3 + Math.random() * 0.2,
                        0.1 + Math.random() * 0.2
                    );
                    break;
                case 'Gaseous':
                    planetColor = new THREE.Color(
                        0.6 + Math.random() * 0.4,
                        0.6 + Math.random() * 0.4,
                        0.7 + Math.random() * 0.3
                    );
                    break;
                case 'Molten':
                    planetColor = new THREE.Color(
                        0.8 + Math.random() * 0.2,
                        0.2 + Math.random() * 0.3,
                        0.05 + Math.random() * 0.1
                    );
                    break;
                case 'Frozen':
                    planetColor = new THREE.Color(
                        0.8 + Math.random() * 0.2,
                        0.8 + Math.random() * 0.2,
                        0.9 + Math.random() * 0.1
                    );
                    break;
                case 'Toxic':
                    planetColor = new THREE.Color(
                        0.2 + Math.random() * 0.2,
                        0.7 + Math.random() * 0.3,
                        0.2 + Math.random() * 0.2
                    );
                    break;
                case 'Oceanic':
                    planetColor = new THREE.Color(
                        0.0 + Math.random() * 0.1,
                        0.4 + Math.random() * 0.3,
                        0.7 + Math.random() * 0.3
                    );
                    break;
                case 'Desert':
                    planetColor = new THREE.Color(
                        0.8 + Math.random() * 0.2,
                        0.7 + Math.random() * 0.2,
                        0.3 + Math.random() * 0.2
                    );
                    break;
                case 'Crystalline':
                    planetColor = new THREE.Color(
                        0.5 + Math.random() * 0.5,
                        0.5 + Math.random() * 0.5,
                        0.5 + Math.random() * 0.5
                    );
                    break;
                default:
                    planetColor = new THREE.Color(
                        0.5 + Math.random() * 0.5,
                        0.5 + Math.random() * 0.5,
                        0.5 + Math.random() * 0.5
                    );
            }
            
            planetMaterial = new THREE.MeshPhongMaterial({
                color: planetColor,
                shininess: 10,
                flatShading: type === 'Rocky' || type === 'Crystalline'
            });
            
            // Create the planet mesh
            const planet = new THREE.Mesh(planetGeometry, planetMaterial);
            
            // Add atmosphere if not a gaseous planet
            if (type !== 'Gaseous') {
                const atmosphereGeometry = new THREE.SphereGeometry(planetSize * 1.02, 64, 64);
                let atmosphereColor;
                
                switch (type) {
                    case 'Molten':
                        atmosphereColor = new THREE.Color(1, 0.3, 0.1);
                        break;
                    case 'Toxic':
                        atmosphereColor = new THREE.Color(0.3, 1, 0.1);
                        break;
                    case 'Oceanic':
                        atmosphereColor = new THREE.Color(0.1, 0.5, 1);
                        break;
                    case 'Frozen':
                        atmosphereColor = new THREE.Color(0.8, 0.9, 1);
                        break;
                    default:
                        atmosphereColor = new THREE.Color(0.8, 0.8, 1);
                }
                
                const atmosphereMaterial = new THREE.MeshBasicMaterial({
                    color: atmosphereColor,
                    transparent: true,
                    opacity: 0.1
                });
                
                const atmosphere = new THREE.Mesh(atmosphereGeometry, atmosphereMaterial);
                planetGroup.add(atmosphere);
            }
            
            // Add planet mesh to the group
            planetGroup.add(planet);
            
            // Add the planet to the scene and state
            scene.add(planetGroup);
            gameState.planets.push({
                group: planetGroup,
                mesh: planet,
                name: planetName,
                size: planetSize,
                rotationSpeed: planetRotationSpeed,
                type: type,
                isDestroyed: false,
                destructionProgress: 0,
                hasBomb: false,
                bombCountdown: 0,
                id: planetId  // Add ID to the planet object
            });
            
            return gameState.planets[gameState.planets.length - 1];
        }
        
        function createPlanets() {
            // Initialize the sectors system
            initializeSectors();
            
            // Create initial planets in different sectors
            for (const sectorKey in gameState.planetsManager.sectors) {
                const sector = gameState.planetsManager.sectors[sectorKey];
                
                // Generate planets for this sector
                for (let i = 0; i < gameState.planetsManager.planetsPerSector; i++) {
                    // Calculate position within sector bounds
                    const position = new THREE.Vector3(
                        sector.center.x + (Math.random() - 0.5) * sector.size,
                        sector.center.y + (Math.random() - 0.5) * sector.size,
                        sector.center.z + (Math.random() - 0.5) * sector.size
                    );
                    
                    const size = 30 + Math.random() * 70;
                    const type = getRandomPlanetMaterial();
                    
                    const planet = createPlanet(position, size, type);
                    planet.sector = sectorKey;
                }
            }
            
            // Create a few close planets for immediate gameplay
            for (let i = 0; i < 3; i++) {
                const distance = 1000 + Math.random() * 1500;
                const angle = Math.random() * Math.PI * 2;
                const height = (Math.random() - 0.5) * 500;
                
                const position = new THREE.Vector3(
                    Math.cos(angle) * distance,
                    height,
                    Math.sin(angle) * distance
                );
                
                const size = 30 + Math.random() * 70;
                const type = getRandomPlanetMaterial();
                
                createPlanet(position, size, type);
            }
        }
        
        function initializeSectors() {
            // Create a grid of sectors to organize the universe
            const sectorSize = gameState.planetsManager.sectorSize;
            const sectorGridSize = 7; // Increased from 3 for a 7x7x7 grid of sectors
            const offset = Math.floor(sectorGridSize / 2);
            
            // Generate sector grid
            for (let x = -offset; x <= offset; x++) {
                for (let y = -offset; y <= offset; y++) {
                    for (let z = -offset; z <= offset; z++) {
                        // Skip the center sector (0,0,0) as it's handled separately
                        if (x === 0 && y === 0 && z === 0) continue;
                        
                        const sectorKey = `SEC-${x}:${y}:${z}`;
                        const sectorName = generateSectorName(x, y, z);
                        
                        gameState.planetsManager.sectors[sectorKey] = {
                            name: sectorName,
                            center: new THREE.Vector3(
                                x * sectorSize,
                                y * sectorSize,
                                z * sectorSize
                            ),
                            size: sectorSize,
                            explored: false,
                            planetTypes: getRandomSectorPlanetTypes()
                        };
                    }
                }
            }
            
            // Add the home sector
            gameState.planetsManager.sectors["SEC-0:0:0"] = {
                name: "ALPHA-1",
                center: new THREE.Vector3(0, 0, 0),
                size: sectorSize,
                explored: true,
                planetTypes: [...planetMaterials] // All types available in home sector
            };
            
            // Create some distant bonus sectors with unique characteristics
            createSpecialSectors();
        }
        
        function createSpecialSectors() {
            // Create a few special distant sectors with unique planet types or characteristics
            
            // 1. Crystal sector - only crystalline planets
            const crystalSectorKey = `SEC-10:5:-8`;
            gameState.planetsManager.sectors[crystalSectorKey] = {
                name: "OMICRON-CRYSTAL",
                center: new THREE.Vector3(
                    10 * gameState.planetsManager.sectorSize,
                    5 * gameState.planetsManager.sectorSize,
                    -8 * gameState.planetsManager.sectorSize
                ),
                size: gameState.planetsManager.sectorSize,
                explored: false,
                planetTypes: ['Crystalline'],
                special: true
            };
            
            // 2. Fire sector - only molten planets
            const fireSectorKey = `SEC-12:-6:9`;
            gameState.planetsManager.sectors[fireSectorKey] = {
                name: "INFERNUS-PRIME",
                center: new THREE.Vector3(
                    12 * gameState.planetsManager.sectorSize,
                    -6 * gameState.planetsManager.sectorSize,
                    9 * gameState.planetsManager.sectorSize
                ),
                size: gameState.planetsManager.sectorSize,
                explored: false,
                planetTypes: ['Molten'],
                special: true
            };
            
            // 3. Ice sector - only frozen planets
            const iceSectorKey = `SEC-8:9:11`;
            gameState.planetsManager.sectors[iceSectorKey] = {
                name: "GLACIUS-VOID",
                center: new THREE.Vector3(
                    8 * gameState.planetsManager.sectorSize,
                    9 * gameState.planetsManager.sectorSize,
                    11 * gameState.planetsManager.sectorSize
                ),
                size: gameState.planetsManager.sectorSize,
                explored: false,
                planetTypes: ['Frozen'],
                special: true
            };
            
            // 4. Water sector - only oceanic planets
            const waterSectorKey = `SEC-9:-7:-10`;
            gameState.planetsManager.sectors[waterSectorKey] = {
                name: "AQUARIS-DEEP",
                center: new THREE.Vector3(
                    9 * gameState.planetsManager.sectorSize,
                    -7 * gameState.planetsManager.sectorSize,
                    -10 * gameState.planetsManager.sectorSize
                ),
                size: gameState.planetsManager.sectorSize,
                explored: false,
                planetTypes: ['Oceanic'],
                special: true
            };
        }
        
        function generateSectorName(x, y, z) {
            // Greek alphabet for sector naming
            const greekLetters = [
                "ALPHA", "BETA", "GAMMA", "DELTA", "EPSILON", 
                "ZETA", "ETA", "THETA", "IOTA", "KAPPA", 
                "LAMBDA", "MU", "NU", "XI", "OMICRON", 
                "PI", "RHO", "SIGMA", "TAU", "UPSILON", 
                "PHI", "CHI", "PSI", "OMEGA"
            ];
            
            // Use coordinates to deterministically select a name
            const index = Math.abs((x * 5 + y * 7 + z * 11) % greekLetters.length);
            const number = Math.abs((x * 3 + y * 5 + z * 7) % 9) + 1;
            
            return `${greekLetters[index]}-${number}`;
        }
        
        function getRandomSectorPlanetTypes() {
            // Each sector has a subset of possible planet types that can appear there
            const types = [...planetMaterials];
            const typeCount = 3 + Math.floor(Math.random() * 3); // 3-5 types per sector
            
            // Shuffle and slice to get random subset
            for (let i = types.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [types[i], types[j]] = [types[j], types[i]];
            }
            
            return types.slice(0, typeCount);
        }
        
        function checkAndGeneratePlanets() {
            // Get current time
            const currentTime = clock.getElapsedTime();
            
            // Only check periodically to save performance
            if (currentTime - gameState.planetsManager.lastCheck < gameState.planetsManager.checkInterval) {
                return;
            }
            
            gameState.planetsManager.lastCheck = currentTime;
            
            // Count intact planets
            const intactPlanets = gameState.planets.filter(planet => !planet.isDestroyed).length;
            
            // Generate new planets if needed
            if (intactPlanets < gameState.planetsManager.minPlanetCount) {
                // Calculate how many planets to generate
                const planetsToGenerate = gameState.planetsManager.minPlanetCount - intactPlanets;
                
                for (let i = 0; i < planetsToGenerate; i++) {
                    generateNewPlanet();
                }
            }
            
            // Update player's current sector
            updatePlayerSector();
        }
        
        function generateNewPlanet() {
            // Get player position
            const playerPosition = new THREE.Vector3();
            gameState.playerShip.getWorldPosition(playerPosition);
            
            // Find the player's current sector
            const playerSector = gameState.playerSector;
            const sectorKeys = Object.keys(gameState.planetsManager.sectors);
            
            // Prefer generating in nearby sectors but not the player's current sector
            let selectedSectorKey;
            
            // 50% chance to generate in a random sector that's not the player's current one
            if (Math.random() < 0.5) {
                do {
                    selectedSectorKey = sectorKeys[Math.floor(Math.random() * sectorKeys.length)];
                } while (gameState.planetsManager.sectors[selectedSectorKey].name === playerSector);
            } 
            // 50% chance to generate in a sector "adjacent" to player's current one
            else {
                const [_, xStr, yStr, zStr] = playerSector.match(/SEC-(-?\d+):(-?\d+):(-?\d+)/) || [null, "0", "0", "0"];
                const x = parseInt(xStr);
                const y = parseInt(yStr);
                const z = parseInt(zStr);
                
                // Randomly adjust one coordinate by +/-1 to get an adjacent sector
                const offset = [[-1,0,0], [1,0,0], [0,-1,0], [0,1,0], [0,0,-1], [0,0,1]];
                const [dx, dy, dz] = offset[Math.floor(Math.random() * offset.length)];
                
                selectedSectorKey = `SEC-${x+dx}:${y+dy}:${z+dz}`;
                
                // Fall back to random sector if the adjacent one doesn't exist
                if (!gameState.planetsManager.sectors[selectedSectorKey]) {
                    selectedSectorKey = sectorKeys[Math.floor(Math.random() * sectorKeys.length)];
                }
            }
            
            const sector = gameState.planetsManager.sectors[selectedSectorKey];
            
            // Random position within the sector
            const position = new THREE.Vector3(
                sector.center.x + (Math.random() - 0.5) * sector.size,
                sector.center.y + (Math.random() - 0.5) * sector.size,
                sector.center.z + (Math.random() - 0.5) * sector.size
            );
            
            // Size and type
            const size = 30 + Math.random() * 70;
            
            // Choose type from the sector's allowed planet types
            const availableTypes = sector.planetTypes;
            const type = availableTypes[Math.floor(Math.random() * availableTypes.length)];
            
            // Create the planet
            const planet = createPlanet(position, size, type);
            planet.sector = selectedSectorKey;
            
            return planet;
        }
        
        function updatePlayerSector() {
            // Get player position
            const playerPosition = new THREE.Vector3();
            gameState.playerShip.getWorldPosition(playerPosition);
            
            // Find the sector containing the player
            let currentSectorKey = "SEC-0:0:0"; // Default to home sector
            const sectorSize = gameState.planetsManager.sectors["SEC-0:0:0"].size;
            
            // Calculate grid coordinates
            const x = Math.round(playerPosition.x / sectorSize);
            const y = Math.round(playerPosition.y / sectorSize);
            const z = Math.round(playerPosition.z / sectorSize);
            
            const potentialSectorKey = `SEC-${x}:${y}:${z}`;
            
            if (gameState.planetsManager.sectors[potentialSectorKey]) {
                currentSectorKey = potentialSectorKey;
            }
            
            // Update sector name in UI
            const sectorName = gameState.planetsManager.sectors[currentSectorKey].name;
            document.getElementById('sector').textContent = sectorName;
            gameState.playerSector = currentSectorKey;
            
            // Mark sector as explored
            gameState.planetsManager.sectors[currentSectorKey].explored = true;
            
            // Update coordinates in UI
            document.getElementById('coordinates').textContent = 
                `${Math.floor(playerPosition.x)},${Math.floor(playerPosition.y)},${Math.floor(playerPosition.z)}`;
        }
        
        function createBomb(position) {
            try {
                const bombGroup = new THREE.Group();
                bombGroup.position.copy(position);
                
                // Add small offset to prevent clipping with the ground
                bombGroup.position.y += 0.5;
                
                // Scale bomb size based on the selected bomb size
                const bombScale = gameState.bombSize;
                
                // Bomb body
                const bombGeometry = new THREE.SphereGeometry(0.5 * bombScale, 16, 16);
                const bombMaterial = new THREE.MeshPhongMaterial({
                    color: 0xff0000,
                    emissive: 0xff0000,
                    emissiveIntensity: 0.5
                });
                
                const bomb = new THREE.Mesh(bombGeometry, bombMaterial);
                bombGroup.add(bomb);
                
                // Add details to make it look more like a bomb
                // Add top fuse
                const fuseGeometry = new THREE.CylinderGeometry(0.05 * bombScale, 0.05 * bombScale, 0.5 * bombScale, 8);
                const fuseMaterial = new THREE.MeshPhongMaterial({ color: 0x333333 });
                const fuse = new THREE.Mesh(fuseGeometry, fuseMaterial);
                fuse.position.y = 0.5 * bombScale;
                bombGroup.add(fuse);
                
                // Blinking light at top of fuse
                const lightGeometry = new THREE.SphereGeometry(0.1 * bombScale, 8, 8);
                const lightMaterial = new THREE.MeshBasicMaterial({
                    color: 0xffff00,
                    transparent: true,
                    opacity: 1
                });
                
                const light = new THREE.Mesh(lightGeometry, lightMaterial);
                light.position.y = 0.75 * bombScale;
                bombGroup.add(light);
                
                // Point light
                const pointLight = new THREE.PointLight(0xff0000, 1, 10 * bombScale);
                bombGroup.add(pointLight);
                
                scene.add(bombGroup);
                
                const newBomb = {
                    group: bombGroup,
                    mesh: bomb,
                    light: light,
                    countdown: 10, // 10 seconds
                    isActive: true,
                    targetPlanet: gameState.landedOnPlanet,
                    size: bombScale // Store bomb size for explosion
                };
                
                gameState.bombs.push(newBomb);
                
                return newBomb;
            } catch (error) {
                console.error("Error creating bomb:", error);
                return null;
            }
        }
        
        function createExplosion(position, size) {
            // Create particle group
            const explosionGroup = new THREE.Group();
            explosionGroup.position.copy(position);
            
            // Create particles
            const particleCount = 100 + Math.floor(size);
            
            for (let i = 0; i < particleCount; i++) {
                const particleGeometry = new THREE.SphereGeometry(Math.random() * 2 + 0.5, 8, 8);
                const particleMaterial = new THREE.MeshBasicMaterial({
                    color: new THREE.Color(
                        Math.random() * 0.5 + 0.5, // R: 0.5-1.0
                        Math.random() * 0.3, // G: 0-0.3
                        0 // B: 0
                    ),
                    transparent: true,
                    opacity: 1
                });
                
                const particle = new THREE.Mesh(particleGeometry, particleMaterial);
                
                // Random position within explosion radius
                const radius = Math.random() * size;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.random() * Math.PI;
                
                particle.position.set(
                    radius * Math.sin(phi) * Math.cos(theta),
                    radius * Math.sin(phi) * Math.sin(theta),
                    radius * Math.cos(phi)
                );
                
                // Random velocity
                const velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 2,
                    (Math.random() - 0.5) * 2,
                    (Math.random() - 0.5) * 2
                );
                velocity.normalize().multiplyScalar(Math.random() * 2 + 1);
                
                explosionGroup.add(particle);
                
                gameState.particles.push({
                    mesh: particle,
                    velocity: velocity,
                    life: 2 + Math.random() * 2, // 2-4 seconds
                    maxLife: 2 + Math.random() * 2
                });
            }
            
            // Add point light
            const explosionLight = new THREE.PointLight(0xff5500, 3, size * 10);
            explosionGroup.add(explosionLight);
            
            scene.add(explosionGroup);
            
            // Flash screen
            const flash = document.getElementById('explosion-flash');
            flash.style.backgroundColor = 'rgba(255, 100, 0, 0.3)';
            setTimeout(() => {
                flash.style.backgroundColor = 'rgba(255, 100, 0, 0)';
            }, 200);
            
            // Create the explosion object
            const explosion = {
                group: explosionGroup,
                light: explosionLight,
                life: 4, // 4 seconds
                size: size
            };
            
            // Add to explosions array
            gameState.explosions.push(explosion);
            
            return explosion;
        }
        
        function createDebris(position, count, size) {
            for (let i = 0; i < count; i++) {
                const debrisGeometry = new THREE.DodecahedronGeometry(
                    (Math.random() * 0.5 + 0.5) * size, 
                    0
                );
                
                const debrisMaterial = new THREE.MeshPhongMaterial({
                    color: 0x888888,
                    flatShading: true
                });
                
                const debris = new THREE.Mesh(debrisGeometry, debrisMaterial);
                debris.position.copy(position);
                
                // Add random offset
                debris.position.x += (Math.random() - 0.5) * size * 2;
                debris.position.y += (Math.random() - 0.5) * size * 2;
                debris.position.z += (Math.random() - 0.5) * size * 2;
                
                // Random rotation
                debris.rotation.set(
                    Math.random() * Math.PI * 2,
                    Math.random() * Math.PI * 2,
                    Math.random() * Math.PI * 2
                );
                
                // Random velocity
                const velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 2,
                    (Math.random() - 0.5) * 2,
                    (Math.random() - 0.5) * 2
                );
                velocity.normalize().multiplyScalar(Math.random() * 5 + 2);
                
                // Random rotation velocity
                const rotationVelocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 0.1,
                    (Math.random() - 0.5) * 0.1,
                    (Math.random() - 0.5) * 0.1
                );
                
                scene.add(debris);
                
                gameState.debris.push({
                    mesh: debris,
                    velocity: velocity,
                    rotationVelocity: rotationVelocity,
                    life: 30 + Math.random() * 30, // 30-60 seconds
                    value: Math.floor(Math.random() * 10) + 1 // Resource value
                });
            }
        }
        
        function createWormhole(position, size = 20, destination = null) {
            const wormholeGroup = new THREE.Group();
            wormholeGroup.position.copy(position);
            
            // Create rings
            const ringsCount = 8;
            const rings = [];
            
            for (let i = 0; i < ringsCount; i++) {
                const ringGeometry = new THREE.TorusGeometry(
                    size * (1 - i * 0.1), 
                    size * 0.05, 
                    16, 
                    32
                );
                
                const ringMaterial = new THREE.MeshBasicMaterial({
                    color: new THREE.Color(0.2 + i * 0.1, 0, 0.5 + i * 0.05),
                    transparent: true,
                    opacity: 0.7 - i * 0.05,
                    side: THREE.DoubleSide
                });
                
                const ring = new THREE.Mesh(ringGeometry, ringMaterial);
                ring.rotation.x = Math.PI / 2;
                wormholeGroup.add(ring);
                rings.push(ring);
            }
            
            // Center distortion sphere
            const coreGeometry = new THREE.SphereGeometry(size * 0.3, 32, 32);
            const coreMaterial = new THREE.MeshBasicMaterial({
                color: 0xffffff,
                transparent: true,
                opacity: 0.8
            });
            
            const core = new THREE.Mesh(coreGeometry, coreMaterial);
            wormholeGroup.add(core);
            
            // Particles
            const particlesGeometry = new THREE.BufferGeometry();
            const particlesMaterial = new THREE.PointsMaterial({
                color: 0xffffff,
                size: 1,
                transparent: true,
                opacity: 0.7
            });
            
            const particlePositions = [];
            const particleCount = 1000;
            
            for (let i = 0; i < particleCount; i++) {
                const radius = Math.random() * size;
                const angle = Math.random() * Math.PI * 2;
                
                particlePositions.push(
                    Math.cos(angle) * radius,
                    (Math.random() - 0.5) * size * 0.5,
                    Math.sin(angle) * radius
                );
            }
            
            particlesGeometry.setAttribute(
                'position',
                new THREE.Float32BufferAttribute(particlePositions, 3)
            );
            
            const particles = new THREE.Points(particlesGeometry, particlesMaterial);
            wormholeGroup.add(particles);
            
            // Add point light
            const wormholeLight = new THREE.PointLight(0x8800ff, 1, size * 10);
            wormholeGroup.add(wormholeLight);
            
            scene.add(wormholeGroup);
            
            // Set destination if none provided
            if (!destination) {
                // Create a destination in another sector
                destination = getWormholeDestination();
            }
            
            gameState.wormholes.push({
                group: wormholeGroup,
                rings: rings,
                core: core,
                particles: particles,
                light: wormholeLight,
                size: size,
                rotationSpeed: 0.01 + Math.random() * 0.02,
                destination: destination
            });
            
            return gameState.wormholes[gameState.wormholes.length - 1];
        }
        
        function getWormholeDestination() {
            // Choose a destination for the wormhole
            // First, get all sector keys
            const sectorKeys = Object.keys(gameState.planetsManager.sectors);
            
            // Remove the current player sector to avoid local wormholes
            const filteredSectors = sectorKeys.filter(key => {
                const sector = gameState.planetsManager.sectors[key];
                return sector.name !== gameState.playerSector;
            });
            
            // Prefer unexplored sectors for discovery (75% chance)
            const unexploredSectors = filteredSectors.filter(key => 
                !gameState.planetsManager.sectors[key].explored
            );
            
            let targetSectorKey;
            
            if (unexploredSectors.length > 0 && Math.random() < 0.75) {
                // Choose an unexplored sector
                targetSectorKey = unexploredSectors[Math.floor(Math.random() * unexploredSectors.length)];
            } else {
                // Choose any non-current sector
                targetSectorKey = filteredSectors[Math.floor(Math.random() * filteredSectors.length)];
            }
            
            // Get the sector information
            const targetSector = gameState.planetsManager.sectors[targetSectorKey];
            
            // Calculate a random position within the target sector
            const position = new THREE.Vector3(
                targetSector.center.x + (Math.random() - 0.5) * targetSector.size * 0.5,
                targetSector.center.y + (Math.random() - 0.5) * targetSector.size * 0.5,
                targetSector.center.z + (Math.random() - 0.5) * targetSector.size * 0.5
            );
            
            return {
                position: position,
                sectorKey: targetSectorKey,
                sectorName: targetSector.name
            };
        }
        
        // Input handlers
        function setupInputHandlers() {
            // Keyboard down
            document.addEventListener('keydown', (event) => {
                switch (event.code) {
                    case 'KeyW':
                        inputState.moveForward = true;
                        break;
                    case 'KeyS':
                        inputState.moveBackward = true;
                        break;
                    case 'KeyA':
                        inputState.moveLeft = true;
                        break;
                    case 'KeyD':
                        inputState.moveRight = true;
                        break;
                    case 'KeyQ':
                        inputState.moveUp = true;
                        break;
                    case 'KeyE':
                        if (gameState.isAlienMode) {
                            // Return to ship
                            if (isNearShip()) {
                                toggleAlienMode();
                            }
                        } else if (gameState.landedOnPlanet) {
                            // Exit as alien
                            toggleAlienMode();
                        }
                        break;
                    case 'ShiftLeft':
                    case 'ShiftRight':
                        // Make sure boost only works if there's fuel
                        if (gameState.boostFuel > 0) {
                            inputState.boost = true;
                            // Add boost activation effect if we weren't already boosting
                            if (!gameState.isBoostActive && !gameState.isAlienMode) {
                                // Create boost activation flash
                                const flash = document.getElementById('explosion-flash');
                                flash.style.backgroundColor = 'rgba(0, 255, 255, 0.2)';
                                setTimeout(() => {
                                    flash.style.backgroundColor = 'rgba(255, 100, 0, 0)';
                                }, 200);
                                
                                // Create extra boost particles for initial burst
                                for (let i = 0; i < 10; i++) {
                                    setTimeout(() => {
                                        if (!gameState.isAlienMode) createBoostParticle();
                                    }, i * 50);
                                }
                            }
                        }
                        break;
                    case 'KeyL':
                        if (!gameState.isAlienMode && !gameState.landedOnPlanet) {
                            attemptLanding();
                        } else if (gameState.landedOnPlanet) {
                            takeOff();
                        }
                        break;
                    case 'KeyB':
                        if (gameState.isAlienMode && gameState.landedOnPlanet) {
                            if (gameState.landedOnPlanet.hasBomb) {
                                showMessage("BOMB ALREADY PLACED ON THIS PLANET", 2000);
                            } else if (gameState.bombsRemaining <= 0) {
                                showMessage("NO BOMBS REMAINING", 2000);
                            } else {
                                // Cycle bomb size when pressing B without placing a bomb
                                gameState.bombSize = (gameState.bombSize % 3) + 1;
                                showMessage(`BOMB SIZE ${gameState.bombSize} SELECTED`, 1000);
                            }
                        }
                        break;
                    case 'KeyP': // Change to P key for actually placing the bomb
                        if (gameState.isAlienMode && gameState.landedOnPlanet && !gameState.landedOnPlanet.hasBomb && gameState.bombsRemaining > 0) {
                            placeBomb();
                        }
                        break;
                    case 'Space':
                        if (!gameState.isAlienMode) {
                            gameState.isTractorBeamActive = true;
                        }
                        break;
                    case 'Escape':
                        toggleTutorial();
                        break;
                }
            });
            
            // Keyboard up
            document.addEventListener('keyup', (event) => {
                switch (event.code) {
                    case 'KeyW':
                        inputState.moveForward = false;
                        break;
                    case 'KeyS':
                        inputState.moveBackward = false;
                        break;
                    case 'KeyA':
                        inputState.moveLeft = false;
                        break;
                    case 'KeyD':
                        inputState.moveRight = false;
                        break;
                    case 'KeyQ':
                        inputState.moveUp = false;
                        break;
                    case 'ShiftLeft':
                    case 'ShiftRight':
                        inputState.boost = false;
                        break;
                    case 'Space':
                        gameState.isTractorBeamActive = false;
                        break;
                }
            });
            
            // Mouse movement for orientation
            document.addEventListener('mousemove', (event) => {
                inputState.mouseX = (event.clientX / window.innerWidth) * 2 - 1;
                inputState.mouseY = -(event.clientY / window.innerHeight) * 2 + 1;
            });
        }
        
        // Utility functions
        function getRandomPlanetName() {
            const prefix = planetPrefixes[Math.floor(Math.random() * planetPrefixes.length)];
            const suffix = planetSuffixes[Math.floor(Math.random() * planetSuffixes.length)];
            return prefix + suffix;
        }
        
        function getRandomPlanetMaterial() {
            return planetMaterials[Math.floor(Math.random() * planetMaterials.length)];
        }
        
        function updateNearestPlanet() {
            let nearest = null;
            let minDistance = Infinity;
            
            const shipPosition = new THREE.Vector3();
            gameState.playerShip.getWorldPosition(shipPosition);
            
            gameState.planets.forEach(planet => {
                if (!planet.isDestroyed) {
                    const planetPosition = new THREE.Vector3();
                    planet.group.getWorldPosition(planetPosition);
                    
                    const distance = shipPosition.distanceTo(planetPosition) - planet.size;
                    
                    if (distance < minDistance) {
                        minDistance = distance;
                        nearest = planet;
                    }
                }
            });
            
            gameState.nearestPlanet = nearest;
            gameState.nearestPlanetDistance = minDistance;
            
            // Update HUD
            if (nearest) {
                document.getElementById('planet-name').textContent = nearest.name;
                document.getElementById('planet-distance').textContent = Math.floor(minDistance);
                document.getElementById('planet-composition').textContent = nearest.type;
                document.getElementById('planet-status').textContent = nearest.hasBomb ? 'BOMB PLANTED' : 'INTACT';
            } else {
                document.getElementById('planet-name').textContent = 'NONE';
                document.getElementById('planet-distance').textContent = '‚àû';
                document.getElementById('planet-composition').textContent = 'UNKNOWN';
                document.getElementById('planet-status').textContent = 'INTACT';
            }
        }
        
        function attemptLanding() {
            if (gameState.isAlienMode || !gameState.nearestPlanet || gameState.isLoading) return;
            
            // Check if we're close enough to land
            if (gameState.nearestPlanetDistance <= gameState.nearestPlanet.size * 2) {
                // Check if the player is moving slow enough to land
                if (gameState.currentVelocity && gameState.currentVelocity.length() > 1.0) {
                    // Too fast to land
                    showMessage("SLOW DOWN TO LAND", 2000);
                    return;
                }
                
                // Store the initial ship state for animation
                const initialPosition = gameState.playerShip.position.clone();
                const initialRotation = gameState.playerShip.quaternion.clone();
                
                // Calculate landing position and orientation
                const planetPosition = new THREE.Vector3();
                gameState.nearestPlanet.group.getWorldPosition(planetPosition);
                
                // Vector from planet to ship (normalized)
                const landingDirection = new THREE.Vector3().subVectors(
                    initialPosition,
                    planetPosition
                ).normalize();
                
                // Calculate final landing position - slightly above planet surface
                const landingPosition = new THREE.Vector3().addVectors(
                    planetPosition,
                    landingDirection.multiplyScalar(gameState.nearestPlanet.size + 1)
                );
                
                // Calculate landing orientation to face the planet surface
                const landingUp = landingDirection.clone(); // Normal to surface is away from planet center
                const landingForward = new THREE.Vector3(0, 1, 0);
                landingForward.crossVectors(landingUp, new THREE.Vector3(1, 0, 0));
                const landingRight = new THREE.Vector3();
                landingRight.crossVectors(landingForward, landingUp);
                
                // Create a rotation matrix from these directions
                const rotMatrix = new THREE.Matrix4().makeBasis(
                    landingRight,
                    landingUp,
                    landingForward
                );
                
                const landingRotation = new THREE.Quaternion().setFromRotationMatrix(rotMatrix);
                
                // Animate landing
                let startTime = null;
                const duration = 2000; // in milliseconds
                
                // Stop any current velocity
                gameState.currentVelocity = new THREE.Vector3(0, 0, 0);
                gameState.speed = 0;
                
                // Display landing message
                showMessage("LANDING SEQUENCE INITIATED", 2000);
                
                function animateLanding(timestamp) {
                    if (!startTime) startTime = timestamp;
                    const elapsed = timestamp - startTime;
                    const progress = Math.min(elapsed / duration, 1);
                    
                    // Ease-in and ease-out
                    const easeProgress = progress < 0.5 ? 
                          2 * progress * progress : 
                          -1 + (4 - 2 * progress) * progress;
                    
                    // Interpolate position
                    gameState.playerShip.position.lerpVectors(
                        initialPosition,
                        landingPosition,
                        easeProgress
                    );
                    
                    // Interpolate rotation (slerp for quaternions)
                    gameState.playerShip.quaternion.slerpQuaternions(
                        initialRotation,
                        landingRotation,
                        easeProgress
                    );
                    
                    if (progress < 1) {
                        requestAnimationFrame(animateLanding);
                    } else {
                        // Set landed planet
                        gameState.landedOnPlanet = gameState.nearestPlanet;
                        
                        // Show success message
                        showMessage("LANDING SUCCESSFUL", 2000);
                        
                        // Automatically enter alien mode after landing with a slight delay
                        setTimeout(() => {
                            toggleAlienMode();
                        }, 500);
                    }
                }
                
                requestAnimationFrame(animateLanding);
            } else {
                showMessage("TOO FAR TO LAND", 2000);
            }
        }
        
        function takeOff() {
            gameState.landedOnPlanet = null;
        }
        
        function toggleAlienMode() {
            if (!gameState.landedOnPlanet) return;
            
            gameState.isAlienMode = !gameState.isAlienMode;
            
            // Send alien mode update to server if multiplayer is enabled
            if (gameState.multiplayer.enabled) {
                sendAlienModeUpdate(
                    gameState.isAlienMode, 
                    gameState.landedOnPlanet ? gameState.landedOnPlanet.id : null
                );
            }
            
            if (gameState.isAlienMode) {
                // Exit as alien
                gameState.alienModel.visible = true;
                
                // Position alien near the ship
                const shipPosition = new THREE.Vector3();
                gameState.playerShip.getWorldPosition(shipPosition);
                
                // Setup the flat scene if not already set up
                if (!gameState.flatScene.getObjectByName('flatGround')) {
                    // Create flat ground for alien to walk on
                    const groundSize = 500; // Larger flat area
                    const groundGeometry = new THREE.PlaneGeometry(groundSize, groundSize, 32, 32);
                    
                    // Use the actual planet's color for the ground
                    const planetMesh = gameState.landedOnPlanet.mesh;
                    const planetColor = planetMesh.material.color.clone();
                    
                    const groundMaterial = new THREE.MeshLambertMaterial({
                        color: planetColor,
                        side: THREE.DoubleSide
                    });
                    
                    const ground = new THREE.Mesh(groundGeometry, groundMaterial);
                    ground.name = 'flatGround';
                    ground.rotation.x = -Math.PI / 2; // Make it flat (horizontal)
                    ground.position.y = 0; // At zero level
                    
                    // Add ground to flat scene
                    gameState.flatScene.add(ground);
                    
                    // Add a directional light to flat scene
                    const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
                    directionalLight.position.set(0, 100, 0);
                    gameState.flatScene.add(directionalLight);
                    
                    // Add ambient light to flat scene
                    const ambientLight = new THREE.AmbientLight(0x404040);
                    gameState.flatScene.add(ambientLight);
                    
                    // Add a ship model to the flat scene as a reference point
                    const shipReference = gameState.playerShip.clone();
                    shipReference.name = 'shipReference';
                    shipReference.position.set(0, 0, 0);
                    shipReference.rotation.set(0, 0, 0);
                    gameState.flatScene.add(shipReference);
                }
                
                // Reset alien position to be in front of the ship reference in flat scene
                gameState.alienModel.position.set(0, 0, 10); // In front of ship
                gameState.alienModel.rotation.set(0, Math.PI, 0); // Facing ship
                gameState.alienModel.scale.set(1, 1, 1);
                
                // Remove alien from main scene and add to flat scene
                gameState.mainScene.remove(gameState.alienModel);
                gameState.flatScene.add(gameState.alienModel);
                
                // Setup camera for alien mode - third person view
                // Remove camera from ship
                gameState.playerShip.remove(gameState.camera);
                
                // Create a camera target if it doesn't exist
                if (!gameState.cameraTarget) {
                    gameState.cameraTarget = new THREE.Object3D();
                }
                
                // Remove camera target from main scene and add to flat scene
                if (gameState.cameraTarget.parent) {
                    gameState.cameraTarget.parent.remove(gameState.cameraTarget);
                }
                gameState.flatScene.add(gameState.cameraTarget);
                
                // Position camera target at alien's head level
                gameState.cameraTarget.position.copy(gameState.alienModel.position);
                gameState.cameraTarget.position.y += 0.6; // Eye level
                
                // Add the camera to the flat scene
                if (gameState.camera.parent) {
                    gameState.camera.parent.remove(gameState.camera);
                }
                gameState.flatScene.add(gameState.camera);
                
                // Initialize starting camera position for animation
                // Put camera behind alien (third person view)
                gameState.camera.position.set(
                    gameState.alienModel.position.x,
                    gameState.alienModel.position.y + 1.5,
                    gameState.alienModel.position.z + 5
                );
                gameState.camera.lookAt(gameState.alienModel.position);
                
                // Reset mouse look state
                gameState.alienMouseLook = {
                    x: 0,
                    y: 0
                };
                
                // Switch to flat scene
                gameState.currentScene = gameState.flatScene;
                
                // Animation for alien emerging from ship and camera transition
                showMessage("ALIEN MODE: WASD TO MOVE, MOUSE TO LOOK, B TO CYCLE BOMB SIZE, P TO PLACE BOMB, E TO RETURN", 4000);
                
            } else {
                // Return to ship
                // Remove alien from flat scene and add back to main scene
                gameState.flatScene.remove(gameState.alienModel);
                gameState.mainScene.add(gameState.alienModel);
                gameState.alienModel.visible = false;
                
                // Move camera back to ship
                if (gameState.camera.parent) {
                    gameState.camera.parent.remove(gameState.camera);
                }
                gameState.playerShip.add(gameState.camera);
                gameState.camera.position.set(0, 3, 10);
                gameState.camera.rotation.set(0, 0, 0);
                
                // Preserve current ship orientation for consistent controls after returning
                // Extract current rotation into our tracking variables
                const currentRotation = new THREE.Euler().setFromQuaternion(gameState.playerShip.quaternion, 'YXZ');
                gameState.shipOrientation.yaw = currentRotation.y;
                gameState.shipOrientation.pitch = currentRotation.x;
                
                // Switch back to main scene
                gameState.currentScene = gameState.mainScene;
                
                // Animation for returning to ship
                showAlienReturnAnimation();
            }
        }
        
        function isNearShip() {
            if (!gameState.isAlienMode) return false;
            
            // Handle different scenes
            if (gameState.currentScene === gameState.flatScene) {
                // In flat scene, check distance to the ship reference
                const shipRef = gameState.flatScene.getObjectByName('shipReference');
                if (shipRef) {
                    return gameState.alienModel.position.distanceTo(shipRef.position) < 5;
                }
                return false;
            } else {
                // In main scene, use the original implementation
                const alienPosition = new THREE.Vector3();
                gameState.alienModel.getWorldPosition(alienPosition);
                
                const shipPosition = new THREE.Vector3();
                gameState.playerShip.getWorldPosition(shipPosition);
                
                return alienPosition.distanceTo(shipPosition) < 3;
            }
        }
        
        function placeBomb() {
            try {
                // Prevent placing multiple bombs on same planet
                if (gameState.landedOnPlanet.hasBomb) {
                    showMessage("BOMB ALREADY PLACED ON THIS PLANET", 2000);
                    return;
                }
                
                // Make sure we have bombs left
                if (gameState.bombsRemaining <= 0) {
                    showMessage("NO BOMBS REMAINING", 2000);
                    return;
                }
                
                // Get alien position for bomb placement
                let bombPosition;
                
                if (gameState.currentScene === gameState.flatScene) {
                    // In flat scene, place bomb at alien's position
                    bombPosition = gameState.alienModel.position.clone();
                    
                    // Add bomb to main scene at corresponding position relative to planet
                    // Get the planet position
                    const planetPosition = new THREE.Vector3();
                    gameState.landedOnPlanet.group.getWorldPosition(planetPosition);
                    
                    // Calculate a position on the planet surface
                    const surfaceNormal = new THREE.Vector3().subVectors(
                        gameState.playerShip.position,
                        planetPosition
                    ).normalize();
                    
                    // Place bomb on planet surface near the ship
                    const realBombPosition = new THREE.Vector3().addVectors(
                        planetPosition,
                        surfaceNormal.multiplyScalar(gameState.landedOnPlanet.size + 0.5)
                    );
                    
                    // Add bomb to main scene
                    const bomb = createBomb(realBombPosition);
                    bomb.targetPlanet = gameState.landedOnPlanet;
                } else {
                    // In main scene, use original implementation
                    bombPosition = new THREE.Vector3();
                    gameState.alienModel.getWorldPosition(bombPosition);
                    
                    // Create bomb at alien's position
                    const bomb = createBomb(bombPosition);
                    bomb.targetPlanet = gameState.landedOnPlanet;
                }
                
                // Send bomb placement to server if multiplayer is enabled
                if (gameState.multiplayer.enabled) {
                    const alienPosition = new THREE.Vector3();
                    gameState.alienModel.getWorldPosition(alienPosition);
                    
                    sendBombPlacement(
                        gameState.landedOnPlanet.id,
                        alienPosition
                    );
                }
                
                // Show feedback message
                showMessage("BOMB PLACED - DETONATION IN 10 SECONDS", 2000);
                
                // Mark planet as having a bomb
                gameState.landedOnPlanet.hasBomb = true;
                gameState.landedOnPlanet.bombCountdown = 10;
                
                // Update HUD bombs count
                gameState.bombsRemaining--;
                document.getElementById('bombs').textContent = gameState.bombsRemaining;
            } catch (error) {
                console.error("Error placing bomb:", error);
                // Reset state to prevent game from freezing
                gameState.landedOnPlanet.hasBomb = true;
                gameState.bombsRemaining = Math.max(0, gameState.bombsRemaining - 1);
                document.getElementById('bombs').textContent = gameState.bombsRemaining;
            }
        }
        
        function updateShipControls(delta) {
            if (gameState.isAlienMode || gameState.isLoading) return;
            
            // Calculate movement speed with improved acceleration and deceleration
            const maxSpeed = gameState.maxSpeed;
            const acceleration = 0.8 * delta; // Slightly reduced for more control
            const deceleration = 1.5 * delta; // Increased for faster stopping
            
            // Handle boost mechanics
            updateBoostMechanics(delta);
            
            // Apply boost if active and has fuel
            const canBoost = gameState.boostFuel > 0 && inputState.boost;
            gameState.isBoostActive = canBoost;
            const speedMultiplier = gameState.isBoostActive ? gameState.boostMultiplier : 1;
            
            // Create movement vectors for all directions
            const forwardVector = new THREE.Vector3(0, 0, -1).applyQuaternion(gameState.playerShip.quaternion);
            const rightVector = new THREE.Vector3(1, 0, 0).applyQuaternion(gameState.playerShip.quaternion);
            const upVector = new THREE.Vector3(0, 1, 0).applyQuaternion(gameState.playerShip.quaternion);
            
            // Store current velocity vector if not yet initialized
            if (!gameState.currentVelocity) {
                gameState.currentVelocity = new THREE.Vector3(0, 0, 0);
            }
            
            // Calculate desired movement direction from input
            const moveDirection = new THREE.Vector3(0, 0, 0);
            
            if (inputState.moveForward) moveDirection.add(forwardVector);
            if (inputState.moveBackward) moveDirection.sub(forwardVector);
            if (inputState.moveRight) moveDirection.add(rightVector);
            if (inputState.moveLeft) moveDirection.sub(rightVector);
            if (inputState.moveUp) moveDirection.add(upVector);
            
            // Flag to determine if there's any directional input
            const hasInput = moveDirection.length() > 0;
            
            if (hasInput) {
                // Normalize direction
                moveDirection.normalize();
                
                // Apply acceleration towards the desired direction
                const targetVelocity = moveDirection.clone().multiplyScalar(maxSpeed * speedMultiplier);
                
                // Smoothly interpolate current velocity towards target velocity
                gameState.currentVelocity.lerp(targetVelocity, acceleration);
                
                // Speed HUD shows magnitude of current velocity
                gameState.speed = gameState.currentVelocity.length();
            } else {
                // No input - gradually decelerate to zero
                if (gameState.currentVelocity.length() > 0) {
                    // Apply deceleration towards zero velocity
                    if (gameState.currentVelocity.length() < deceleration) {
                        // If very slow, just stop completely
                        gameState.currentVelocity.set(0, 0, 0);
                    } else {
                        // Apply deceleration in the opposite direction of movement
                        const decelerationVector = gameState.currentVelocity.clone().normalize().multiplyScalar(-deceleration);
                        gameState.currentVelocity.add(decelerationVector);
                    }
                    
                    // Update speed display
                    gameState.speed = gameState.currentVelocity.length();
                }
            }
            
            // Apply the current velocity to the ship position
            gameState.playerShip.position.add(gameState.currentVelocity);
            
            // Use a better camera control system that prevents gimbal lock
            // and ensures consistent up/down control
            
            // Track yaw and pitch separately rather than directly manipulating rotation
            if (!gameState.shipOrientation) {
                gameState.shipOrientation = {
                    yaw: 0,
                    pitch: 0
                };
            }
            
            // Update orientation based on mouse movement
            const lookSpeed = 0.07;
            gameState.shipOrientation.yaw -= inputState.mouseX * lookSpeed;
            gameState.shipOrientation.pitch += inputState.mouseY * lookSpeed;
            
            // Clamp pitch to prevent flipping
            const pitchLimit = Math.PI / 2.5;
            gameState.shipOrientation.pitch = Math.max(-pitchLimit, Math.min(pitchLimit, gameState.shipOrientation.pitch));
            
            // Apply rotations in the correct order using quaternions to avoid gimbal lock
            // Reset rotation first
            gameState.playerShip.rotation.set(0, 0, 0);
            gameState.playerShip.quaternion.setFromEuler(new THREE.Euler(0, 0, 0));
            
            // Apply yaw (rotation around Y axis)
            const yawQuat = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 1, 0), gameState.shipOrientation.yaw);
            gameState.playerShip.quaternion.multiply(yawQuat);
            
            // Apply pitch (rotation around X axis)
            const pitchQuat = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(1, 0, 0), gameState.shipOrientation.pitch);
            gameState.playerShip.quaternion.multiply(pitchQuat);
            
            // Add roll effect while turning (bank into turns)
            if (Math.abs(inputState.mouseX) > 0.05) {
                // Calculate roll based on turning rate and direction
                const targetRoll = -inputState.mouseX * 0.5; // Max roll of 0.5 radians
                
                // Apply roll (rotation around Z axis)
                const rollQuat = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 0, 1), targetRoll);
                gameState.playerShip.quaternion.multiply(rollQuat);
            }
            
            // Update HUD
            document.getElementById('speed').textContent = Math.abs(gameState.speed).toFixed(1);
            
            // Update the orientation indicator
            updateOrientationIndicator();
            
            // Update boost effect
            updateBoostEffect();
        }
        
        function updateOrientationIndicator() {
            // Update visual indicator for orientation
            const indicator = document.getElementById('orientation-dot');
            if (indicator) {
                const maxOffset = 35; // Maximum pixel offset from center
                
                // Calculate position based on pitch and yaw, normalized to [-1, 1] range
                const pitchNormalized = gameState.shipOrientation.pitch / (Math.PI / 2);
                const yawNormalized = gameState.shipOrientation.yaw / Math.PI;
                
                // Calculate dot position (inverted Y for visual representation)
                const dotX = yawNormalized * maxOffset;
                const dotY = -pitchNormalized * maxOffset;
                
                // Apply transform
                indicator.style.transform = `translate(${dotX}px, ${dotY}px)`;
            }
        }
        
        function updateBoostMechanics(delta) {
            // Update boost fuel
            if (gameState.isBoostActive && gameState.boostFuel > 0) {
                // Drain fuel while boosting
                gameState.boostFuel = Math.max(0, gameState.boostFuel - gameState.boostDrainRate * delta);
                
                // Create boost particles if not in alien mode
                if (!gameState.isAlienMode && gameState.boostFuel > 0 && Math.random() > 0.5) {
                    createBoostParticle();
                }
            } else if (!gameState.isBoostActive && gameState.boostFuel < gameState.maxBoostFuel) {
                // Recharge fuel when not boosting
                gameState.boostFuel = Math.min(
                    gameState.maxBoostFuel, 
                    gameState.boostFuel + gameState.boostRechargeRate * delta
                );
            }
            
            // Update boost meter fill
            const boostMeterFill = document.getElementById('boost-meter-fill');
            const boostPercentage = gameState.boostFuel / gameState.maxBoostFuel;
            boostMeterFill.style.transform = `scaleX(${boostPercentage})`;
            
            // Change color based on fuel level
            if (boostPercentage < 0.3) {
                boostMeterFill.style.backgroundColor = '#ff3333';
            } else if (boostPercentage < 0.6) {
                boostMeterFill.style.backgroundColor = '#ffff33';
            } else {
                boostMeterFill.style.backgroundColor = '#00ffff';
            }
        }
        
        function createBoostParticle() {
            // Create a particle behind the ship for boost effect
            const particleGeometry = new THREE.SphereGeometry(0.2, 8, 8);
            const particleMaterial = new THREE.MeshBasicMaterial({
                color: new THREE.Color(0.5, 0.8, 1),
                transparent: true,
                opacity: 0.7
            });
            
            const particle = new THREE.Mesh(particleGeometry, particleMaterial);
            
            // Position behind the ship
            const shipPosition = new THREE.Vector3();
            gameState.playerShip.getWorldPosition(shipPosition);
            
            const shipDirection = new THREE.Vector3(0, 0, 1); // Backward
            shipDirection.applyQuaternion(gameState.playerShip.quaternion);
            shipDirection.multiplyScalar(2 + Math.random() * 0.5);
            
            particle.position.copy(shipPosition).add(shipDirection);
            
            // Add slight randomness to position
            particle.position.x += (Math.random() - 0.5) * 0.5;
            particle.position.y += (Math.random() - 0.5) * 0.5;
            particle.position.z += (Math.random() - 0.5) * 0.5;
            
            // Set velocity
            const velocity = shipDirection.clone().multiplyScalar(0.5);
            
            scene.add(particle);
            
            gameState.boostEffects.push({
                mesh: particle,
                velocity: velocity,
                life: 1 + Math.random() * 0.5 // 1-1.5 seconds
            });
        }
        
        function updateBoostEffect() {
            // Update boost particles
            for (let i = gameState.boostEffects.length - 1; i >= 0; i--) {
                const effect = gameState.boostEffects[i];
                
                // Update position
                effect.mesh.position.add(effect.velocity);
                
                // Update size
                effect.mesh.scale.multiplyScalar(0.95);
                
                // Update life
                effect.life -= clock.getDelta();
                
                // Update opacity
                effect.mesh.material.opacity = effect.life / 1.5;
                
                // Remove if dead
                if (effect.life <= 0) {
                    scene.remove(effect.mesh);
                    gameState.boostEffects.splice(i, 1);
                }
            }
        }
        
        function updateAlienControls(delta) {
            if (!gameState.isAlienMode || gameState.isLoading) return;
            
            const moveSpeed = 10 * delta; // Increased speed
            
            // Third person camera control with mouse
            const mouseSensitivity = 0.002;
            
            // Update alien's viewing direction based on mouse input
            gameState.alienMouseLook.x -= inputState.mouseX * mouseSensitivity;
            gameState.alienMouseLook.y = Math.max(
                -Math.PI / 4, // Limit looking down
                Math.min(Math.PI / 6, gameState.alienMouseLook.y + inputState.mouseY * mouseSensitivity) // Limit looking up
            );
            
            // Update camera target (attached to alien)
            gameState.cameraTarget.position.copy(gameState.alienModel.position);
            gameState.cameraTarget.position.y += 0.8; // Slightly above alien's head
            
            // Apply alien's rotation based on mouse look
            // Reset rotation first
            gameState.cameraTarget.quaternion.setFromEuler(new THREE.Euler(0, 0, 0));
            
            // Apply yaw (horizontal rotation)
            const yawQuat = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 1, 0), gameState.alienMouseLook.x);
            gameState.cameraTarget.quaternion.multiply(yawQuat);
            
            // Apply pitch (vertical rotation - for camera only, not alien movement)
            const pitchQuat = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(1, 0, 0), gameState.alienMouseLook.y);
            gameState.cameraTarget.quaternion.multiply(pitchQuat);
            
            // Calculate camera position - third person view behind alien
            // Get the backward direction from alien's target
            const backward = new THREE.Vector3(0, 0, 1);
            backward.applyQuaternion(gameState.cameraTarget.quaternion);
            
            // Position camera behind alien (third person view) and offset vertically
            const cameraPos = new THREE.Vector3().addVectors(
                gameState.cameraTarget.position,
                new THREE.Vector3(
                    backward.x * 3, // 3 units behind
                    backward.y * 1.5 + 1, // Offset up + pitch component
                    backward.z * 3 // 3 units behind
                )
            );
            
            // Update camera position
            gameState.camera.position.copy(cameraPos);
            
            // Make camera look at target (alien's head)
            gameState.camera.lookAt(gameState.cameraTarget.position);
            
            // Get movement direction vectors relative to camera orientation (ignoring pitch)
            // Forward direction is opposite of camera/alien look direction but with y=0 (horizontal movement)
            const forward = new THREE.Vector3(0, 0, -1);
            forward.applyQuaternion(new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 1, 0), gameState.alienMouseLook.x));
            forward.y = 0; // Keep movement parallel to ground
            forward.normalize();
            
            // Right direction is perpendicular to forward
            const right = new THREE.Vector3(1, 0, 0);
            right.applyQuaternion(new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 1, 0), gameState.alienMouseLook.x));
            right.y = 0; // Keep movement parallel to ground
            right.normalize();
            
            // Calculate movement direction from input
            const moveDirection = new THREE.Vector3(0, 0, 0);
            
            if (inputState.moveForward) moveDirection.add(forward);
            if (inputState.moveBackward) moveDirection.sub(forward);
            if (inputState.moveRight) moveDirection.add(right);
            if (inputState.moveLeft) moveDirection.sub(right);
            
            if (moveDirection.length() > 0) {
                moveDirection.normalize();
                moveDirection.multiplyScalar(moveSpeed);
                
                // Move alien
                gameState.alienModel.position.add(moveDirection);
                
                // Keep alien on flat ground (y=0)
                gameState.alienModel.position.y = 0;
                
                // Orient alien to face movement direction
                if (moveDirection.length() > 0.1) {
                    // Create a quaternion that rotates from forward vector to movement direction
                    const targetRotation = new THREE.Quaternion().setFromUnitVectors(
                        new THREE.Vector3(0, 0, 1),
                        new THREE.Vector3(moveDirection.x, 0, moveDirection.z).normalize()
                    );
                    
                    // Apply rotation
                    gameState.alienModel.quaternion.copy(targetRotation);
                }
            }
            
            // Check if near ship for return
            // Get ship reference in flat scene
            const shipRef = gameState.flatScene.getObjectByName('shipReference');
            if (shipRef) {
                const distanceToShip = gameState.alienModel.position.distanceTo(shipRef.position);
                if (distanceToShip < 5) {
                    showMessage("PRESS E TO RETURN TO SHIP", 1000);
                }
            }
        }
        
        function updateBombs(delta) {
            gameState.bombs.forEach((bomb, index) => {
                if (!bomb.isActive) return;
                
                // Update countdown
                bomb.countdown -= delta;
                
                // Blink light faster as countdown decreases
                const blinkSpeed = 1 - bomb.countdown / 10; // 0-1 range
                bomb.light.visible = Math.sin(Date.now() * 10 * blinkSpeed) > 0;
                
                // Check if bomb should explode
                if (bomb.countdown <= 0) {
                    // Remove bomb
                    scene.remove(bomb.group);
                    bomb.isActive = false;
                    
                    // Create explosion
                    const explosionPosition = new THREE.Vector3();
                    bomb.group.getWorldPosition(explosionPosition);
                    
                    // Use bomb size to determine explosion size (default to 30 if size not defined)
                    const bombSize = bomb.size || 1;
                    const explosionSize = 30 * bombSize;
                    
                    const explosion = createExplosion(explosionPosition, explosionSize);
                    
                    // Destroy planet
                    if (bomb.targetPlanet && !bomb.targetPlanet.isDestroyed) {
                        destroyPlanet(bomb.targetPlanet);
                    }
                    
                    // Remove bomb from array
                    gameState.bombs.splice(index, 1);
                }
            });
        }
        
        function destroyPlanet(planet) {
            if (planet.isDestroyed) return;
            
            // Mark planet as destroyed
            planet.isDestroyed = true;
            
            // Send planet destruction to server if multiplayer is enabled
            if (gameState.multiplayer.enabled) {
                sendPlanetDestruction(planet.id);
            }
            
            // Create explosion
            const planetPosition = new THREE.Vector3();
            planet.group.getWorldPosition(planetPosition);
            
            // Size explosion based on planet size
            const explosionSize = planet.size * 2;
            
            // Create the explosion
            createExplosion(planetPosition, explosionSize);
            
            // Create debris
            const debrisCount = Math.floor(planet.size * 0.5);
            createDebris(planetPosition, debrisCount, planet.size * 0.1);
            
            // Hide the planet
            planet.group.visible = false;
            
            // Increment counter and update UI
            gameState.planetsDestroyed++;
            document.getElementById('destroyed').textContent = gameState.planetsDestroyed;
            
            // Show destruction rating
            showDestructionRating(planet);
            
            // If a player is landed on this planet, force them to take off
            if (gameState.landedOnPlanet === planet) {
                // Force exit alien mode
                if (gameState.isAlienMode) {
                    toggleAlienMode();
                }
                
                // Take off from the planet
                takeOff();
            }
            
            // Remove the planet after a delay
            setTimeout(() => {
                scene.remove(planet.group);
            }, 5000);
        }
        
        function showDestructionRating(planet) {
            const destructionRating = document.getElementById('destruction-rating');
            const destroyedPlanet = document.getElementById('destroyed-planet');
            const destructionEfficiency = document.getElementById('destruction-efficiency');
            const resourcesCollected = document.getElementById('resources-collected');
            const destructionBonus = document.getElementById('destruction-bonus');
            
            // Set values
            destroyedPlanet.textContent = planet.name;
            
            // Random efficiency for demo
            const efficiency = Math.floor(Math.random() * 40) + 60; // 60-100%
            destructionEfficiency.textContent = efficiency;
            
            // Resources based on planet size
            const resources = Math.floor(planet.size / 2);
            resourcesCollected.textContent = resources;
            gameState.resourcesCollected += resources;
            
            // Bonus
            const bonuses = ['PERFECT TIMING', 'CORE STRIKE', 'COMPLETE VAPORIZATION', 'NONE'];
            const bonus = bonuses[Math.floor(Math.random() * bonuses.length)];
            destructionBonus.textContent = bonus;
            
            // Show rating
            destructionRating.style.display = 'block';
            
            // Hide after 5 seconds
            setTimeout(() => {
                destructionRating.style.display = 'none';
            }, 5000);
        }
        
        function updateParticles(delta) {
            gameState.particles.forEach((particle, index) => {
                // Update position
                particle.mesh.position.add(
                    particle.velocity.clone().multiplyScalar(delta * 10)
                );
                
                // Update life
                particle.life -= delta;
                
                // Update material opacity based on life
                particle.mesh.material.opacity = particle.life / particle.maxLife;
                
                // Remove if dead
                if (particle.life <= 0) {
                    particle.mesh.parent.remove(particle.mesh);
                    gameState.particles.splice(index, 1);
                }
            });
        }
        
        function updateDebris(delta) {
            // Loop through debris in reverse to safely remove items
            for (let i = gameState.debris.length - 1; i >= 0; i--) {
                const debris = gameState.debris[i];
                
                // Update position
                debris.mesh.position.add(debris.velocity.clone().multiplyScalar(delta));
                
                // Update rotation
                debris.mesh.rotation.x += debris.rotationVelocity.x;
                debris.mesh.rotation.y += debris.rotationVelocity.y;
                debris.mesh.rotation.z += debris.rotationVelocity.z;
                
                // Apply some drag to slow down debris over time
                debris.velocity.multiplyScalar(0.99);
                
                // Update life
                debris.life -= delta;
                
                // Check for tractor beam if active
                if (gameState.isTractorBeamActive && !gameState.isAlienMode) {
                    const playerPosition = new THREE.Vector3();
                    gameState.playerShip.getWorldPosition(playerPosition);
                    
                    // Check if debris is within tractor beam range
                    const distance = debris.mesh.position.distanceTo(playerPosition);
                    const tractorRange = 50; // Range of tractor beam
                    
                    if (distance < tractorRange) {
                        // Pull debris toward player
                        const pullDirection = new THREE.Vector3().subVectors(
                            playerPosition, 
                            debris.mesh.position
                        ).normalize();
                        
                        // Add pull force to velocity
                        const pullStrength = 20 * delta * (1 - distance / tractorRange);
                        debris.velocity.add(pullDirection.multiplyScalar(pullStrength));
                        
                        // If very close to player, collect it
                        if (distance < 5) {
                            // Add resource value
                            gameState.resourcesCollected += debris.value;
                            
                            // Remove debris
                            scene.remove(debris.mesh);
                            gameState.debris.splice(i, 1);
                            
                            // Show message
                            showMessage(`RESOURCE COLLECTED: +${debris.value}`, 1000);
                            
                            // Continue loop
                            continue;
                        }
                    }
                }
                
                // Remove if dead
                if (debris.life <= 0) {
                    scene.remove(debris.mesh);
                    gameState.debris.splice(i, 1);
                }
            }
        }
        
        function updatePlanets(delta) {
            // Update each planet
            gameState.planets.forEach(planet => {
                if (planet.isDestroyed) return;
                
                // Rotate the planet
                planet.group.rotation.y += planet.rotationSpeed;
                
                // Update bomb countdown if planet has a bomb
                if (planet.hasBomb) {
                    planet.bombCountdown -= delta;
                    
                    // Update UI if this is the nearest planet
                    if (planet === gameState.nearestPlanet) {
                        document.getElementById('planet-status').textContent = 
                            `BOMB: ${Math.ceil(planet.bombCountdown)}s`;
                    }
                }
            });
        }
        
        function updateTractorBeam() {
            // Only active when not in alien mode and tractor beam is on
            if (gameState.isAlienMode || !gameState.isTractorBeamActive) {
                // Remove tractor beam if it exists
                if (gameState.tractorBeamEffect) {
                    scene.remove(gameState.tractorBeamEffect);
                    gameState.tractorBeamEffect = null;
                }
                return;
            }
            
            // Create tractor beam if it doesn't exist
            if (!gameState.tractorBeamEffect) {
                const beamGeometry = new THREE.CylinderGeometry(5, 20, 100, 16, 1, true);
                const beamMaterial = new THREE.MeshBasicMaterial({
                    color: 0x00ffff,
                    transparent: true,
                    opacity: 0.3,
                    side: THREE.DoubleSide
                });
                
                gameState.tractorBeamEffect = new THREE.Mesh(beamGeometry, beamMaterial);
                scene.add(gameState.tractorBeamEffect);
            }
            
            // Position and orient tractor beam in front of the ship
            const shipPosition = new THREE.Vector3();
            gameState.playerShip.getWorldPosition(shipPosition);
            
            // Forward direction from ship
            const forwardVector = new THREE.Vector3(0, 0, -1);
            forwardVector.applyQuaternion(gameState.playerShip.quaternion);
            
            // Position beam in front of ship
            gameState.tractorBeamEffect.position.copy(shipPosition);
            gameState.tractorBeamEffect.position.add(forwardVector.multiplyScalar(50));
            
            // Rotate beam to match ship orientation
            gameState.tractorBeamEffect.quaternion.copy(gameState.playerShip.quaternion);
            gameState.tractorBeamEffect.rotation.x += Math.PI / 2; // Adjust to point forward
            
            // Animate beam effect
            const time = Date.now() * 0.001;
            gameState.tractorBeamEffect.material.opacity = 0.2 + Math.sin(time * 5) * 0.1;
            gameState.tractorBeamEffect.scale.y = 0.9 + Math.sin(time * 3) * 0.1;
        }
        
        function updateWormholes(delta) {
            // Update each wormhole
            gameState.wormholes.forEach(wormhole => {
                // Rotate the rings in alternating directions
                wormhole.rings.forEach((ring, index) => {
                    ring.rotation.z += wormhole.rotationSpeed * (index % 2 === 0 ? 1 : -1);
                });
                
                // Pulse the core
                const time = Date.now() * 0.001;
                const scale = 0.8 + Math.sin(time * 2) * 0.2;
                wormhole.core.scale.set(scale, scale, scale);
                
                // Rotate the particles
                wormhole.particles.rotation.z += wormhole.rotationSpeed * 0.5;
                
                // Check if player is very close to wormhole
                const playerPosition = new THREE.Vector3();
                gameState.playerShip.getWorldPosition(playerPosition);
                
                const wormholePosition = new THREE.Vector3();
                wormhole.group.getWorldPosition(wormholePosition);
                
                const distance = playerPosition.distanceTo(wormholePosition);
                
                // If very close and not in alien mode, show message
                if (distance < wormhole.size * 5 && !gameState.isAlienMode) {
                    showMessage("WORMHOLE DETECTED: APPROACH TO TRAVEL", 1000);
                }
            });
        }
        
        function checkWormholeProximity() {
            // Only check if not in alien mode
            if (gameState.isAlienMode) return;
            
            // Get player position
            const playerPosition = new THREE.Vector3();
            gameState.playerShip.getWorldPosition(playerPosition);
            
            // Check each wormhole
            for (let i = 0; i < gameState.wormholes.length; i++) {
                const wormhole = gameState.wormholes[i];
                
                const wormholePosition = new THREE.Vector3();
                wormhole.group.getWorldPosition(wormholePosition);
                
                const distance = playerPosition.distanceTo(wormholePosition);
                
                // If player is inside wormhole, teleport
                if (distance < wormhole.size * 1.5) {
                    // Get destination
                    const destination = wormhole.destination;
                    
                    // Create teleport effect
                    const flash = document.getElementById('explosion-flash');
                    flash.style.backgroundColor = 'rgba(170, 0, 255, 0.5)';
                    
                    // Show message
                    showMessage(`ENTERING WORMHOLE TO ${destination.sectorName}`, 3000);
                    
                    // Teleport player to destination after delay
                    setTimeout(() => {
                        // Reset flash
                        flash.style.backgroundColor = 'rgba(255, 100, 0, 0)';
                        
                        // Teleport player
                        gameState.playerShip.position.copy(destination.position);
                        
                        // Show arrival message
                        showMessage(`ARRIVED IN SECTOR ${destination.sectorName}`, 3000);
                        
                        // Create return wormhole at destination
                        const currentPosition = wormholePosition.clone();
                        
                        // Create return wormhole slightly offset from arrival position
                        const returnPosition = destination.position.clone();
                        returnPosition.x += 100 + Math.random() * 100;
                        returnPosition.z += 100 + Math.random() * 100;
                        
                        // Create the return wormhole
                        createWormhole(returnPosition, wormhole.size, {
                            position: currentPosition,
                            sectorName: gameState.playerSector,
                            sectorKey: gameState.playerSector
                        });
                    }, 1000);
                    
                    // Only handle one wormhole at a time
                    break;
                }
            }
        }
        
        function showMessage(text, duration = 2000) {
            const messageBox = document.getElementById('message-box');
            messageBox.textContent = text;
            messageBox.style.opacity = 1;
            
            // Clear previous timeout if exists
            if (gameState.activeMessages.length > 0) {
                const lastMessage = gameState.activeMessages[gameState.activeMessages.length - 1];
                clearTimeout(lastMessage.timeout);
                gameState.activeMessages.pop();
            }
            
            // Set new timeout
            const messageTimeout = setTimeout(() => {
                messageBox.style.opacity = 0;
                
                // Remove this message from active messages
                const index = gameState.activeMessages.findIndex(m => m.id === messageId);
                if (index !== -1) {
                    gameState.activeMessages.splice(index, 1);
                }
            }, duration);
            
            // Generate a unique ID for this message
            const messageId = Date.now();
            
            // Store the message and its timeout
            gameState.activeMessages.push({
                id: messageId,
                text: text,
                timeout: messageTimeout
            });
        }
        
        function updateMinimap() {
            // Simulate loading progress
            gameState.minimapUpdateTimer += clock.getDelta();
            if (gameState.minimapUpdateTimer < gameState.minimapUpdateInterval) {
                return;
            }
            gameState.minimapUpdateTimer = 0; // This line is crucial
            
            // Clear previous minimap dots
            const minimapDots = document.getElementById('minimap-dots');
            minimapDots.innerHTML = '';
            
            // Add player's position
            const playerDot = document.createElement('div');
            playerDot.className = 'minimap-dot player';
            playerDot.style.left = '50%';
            playerDot.style.top = '50%';
            minimapDots.appendChild(playerDot);
            
            // Get player position
            const playerPosition = new THREE.Vector3();
            gameState.playerShip.getWorldPosition(playerPosition);
            
            // Calculate minimap scale - show objects within 20000 units
            const minimapRadius = 20000;
            const minimapScale = 100 / minimapRadius;
            
            // Add planets to minimap
            gameState.planets.forEach(planet => {
                if (planet.isDestroyed) return;
                
                const planetPosition = new THREE.Vector3();
                planet.group.getWorldPosition(planetPosition);
                
                // Calculate relative position
                const relativePosition = {
                    x: planetPosition.x - playerPosition.x,
                    z: planetPosition.z - playerPosition.z
                };
                
                // Skip if outside minimap radius
                const distance = Math.sqrt(relativePosition.x * relativePosition.x + relativePosition.z * relativePosition.z);
                if (distance > minimapRadius) return;
                
                // Calculate minimap coordinates
                const minimapX = 50 + (relativePosition.x * minimapScale);
                const minimapY = 50 + (relativePosition.z * minimapScale);
                
                // Create planet dot
                const planetDot = document.createElement('div');
                planetDot.className = 'minimap-dot';
                planetDot.style.left = minimapX + '%';
                planetDot.style.top = minimapY + '%';
                
                // Set color based on planet type
                let dotColor;
                switch (planet.type) {
                    case 'Rocky': dotColor = '#a67c52'; break;
                    case 'Gaseous': dotColor = '#a8c8ff'; break;
                    case 'Molten': dotColor = '#ff5500'; break;
                    case 'Frozen': dotColor = '#aaddff'; break;
                    case 'Toxic': dotColor = '#55ff55'; break;
                    case 'Oceanic': dotColor = '#0088ff'; break;
                    case 'Desert': dotColor = '#ffcc44'; break;
                    case 'Crystalline': dotColor = '#ff00ff'; break;
                    default: dotColor = '#ffffff';
                }
                
                planetDot.style.backgroundColor = dotColor;
                
                // Add a glow to the dot for the nearest planet
                if (planet === gameState.nearestPlanet) {
                    planetDot.style.boxShadow = '0 0 5px #fff';
                }
                
                // Highlight planets with bombs
                if (planet.hasBomb) {
                    planetDot.style.backgroundColor = '#ff0000';
                    planetDot.style.boxShadow = '0 0 7px #ff0000';
                }
                
                minimapDots.appendChild(planetDot);
            });
            
            // Add wormholes to minimap
            gameState.wormholes.forEach(wormhole => {
                const wormholePosition = new THREE.Vector3();
                wormhole.group.getWorldPosition(wormholePosition);
                
                // Calculate relative position
                const relativePosition = {
                    x: wormholePosition.x - playerPosition.x,
                    z: wormholePosition.z - playerPosition.z
                };
                
                // Skip if outside minimap radius
                const distance = Math.sqrt(relativePosition.x * relativePosition.x + relativePosition.z * relativePosition.z);
                if (distance > minimapRadius) return;
                
                // Calculate minimap coordinates
                const minimapX = 50 + (relativePosition.x * minimapScale);
                const minimapY = 50 + (relativePosition.z * minimapScale);
                
                // Create wormhole dot
                const wormholeDot = document.createElement('div');
                wormholeDot.className = 'minimap-dot';
                wormholeDot.style.left = minimapX + '%';
                wormholeDot.style.top = minimapY + '%';
                wormholeDot.style.backgroundColor = '#aa00ff';
                wormholeDot.style.boxShadow = '0 0 5px #aa00ff';
                
                minimapDots.appendChild(wormholeDot);
            });
            
            // Add markers for other players if multiplayer is enabled
            if (gameState.multiplayer.enabled) {
                addPlayerMarkersToMinimap();
            }
        }
        
        // Multiplayer functions
        function initMultiplayer() {
            // Check if multiplayer is already enabled
            if (gameState.multiplayer.enabled) return;
            
            // Create WebSocket connection
            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsUrl = `${protocol}//${window.location.host}`;
            
            console.log(`Connecting to WebSocket server at ${wsUrl}`);
            
            try {
                const socket = new WebSocket(wsUrl);
                gameState.multiplayer.socket = socket;
                
                // Connection opened
                socket.addEventListener('open', (event) => {
                    console.log('Connected to multiplayer server');
                    gameState.multiplayer.enabled = true;
                    
                    // Show connection message
                    showMessage('CONNECTED TO MULTIPLAYER SERVER', 3000);
                    
                    // Add chat input UI
                    addChatInterface();
                    
                    // Update button text
                    const button = document.getElementById('multiplayer-toggle');
                    if (button) {
                        button.textContent = 'DISABLE MULTIPLAYER';
                    }
                });
                
                // Listen for messages
                socket.addEventListener('message', (event) => {
                    try {
                        const data = JSON.parse(event.data);
                        console.log('Received server message:', data.type);
                        handleServerMessage(data);
                    } catch (error) {
                        console.error('Error parsing server message:', error);
                    }
                });
                
                // Connection closed
                socket.addEventListener('close', (event) => {
                    console.log('Disconnected from multiplayer server:', event.code, event.reason);
                    gameState.multiplayer.enabled = false;
                    showMessage('DISCONNECTED FROM MULTIPLAYER SERVER', 3000);
                    
                    // Clean up other players
                    gameState.multiplayer.otherPlayers.forEach((player) => {
                        scene.remove(player.model);
                    });
                    gameState.multiplayer.otherPlayers.clear();
                    
                    // Remove chat interface
                    removeChatInterface();
                    
                    // Update button text
                    const button = document.getElementById('multiplayer-toggle');
                    if (button) {
                        button.textContent = 'ENABLE MULTIPLAYER';
                    }
                });
                
                // Handle connection errors
                socket.addEventListener('error', (event) => {
                    console.error('WebSocket error:', event);
                    showMessage('MULTIPLAYER CONNECTION ERROR', 3000);
                    
                    // Update button text in case of error
                    const button = document.getElementById('multiplayer-toggle');
                    if (button) {
                        button.textContent = 'RETRY MULTIPLAYER';
                    }
                });
            } catch (error) {
                console.error('Failed to create WebSocket connection:', error);
                showMessage('FAILED TO CONNECT TO SERVER', 3000);
            }
        }
        
        // Handle messages from the server
        function handleServerMessage(data) {
            // Update last server message time for connection monitoring
            gameState.multiplayer.lastServerMessage = Date.now();
            
            switch (data.type) {
                case 'init':
                    // Initial connection data
                    gameState.multiplayer.playerId = data.playerId;
                    gameState.multiplayer.playerColor = data.playerColor;
                    
                    // Update player ship color
                    updatePlayerShipColor(data.playerColor);
                    
                    // Initialize other players
                    Object.values(data.players).forEach(playerData => {
                        if (playerData.id !== gameState.multiplayer.playerId) {
                            createOtherPlayerShip(playerData);
                        }
                    });
                    
                    showMessage(`ASSIGNED PLAYER ID: ${data.playerId}`, 3000);
                    updateActivePlayers(); // Update active players list
                    break;
                    
                case 'playerJoined':
                    // New player joined
                    createOtherPlayerShip(data.player);
                    showMessage(`PLAYER ${data.player.id} JOINED`, 2000);
                    updateActivePlayers(); // Update active players list
                    break;
                    
                case 'playerLeft':
                    // Player left
                    removeOtherPlayerShip(data.playerId);
                    showMessage(`PLAYER ${data.playerId} LEFT`, 2000);
                    updateActivePlayers(); // Update active players list
                    break;
                    
                case 'gameState':
                    // Update all player positions
                    updateOtherPlayersPositions(data.players);
                    break;
                    
                case 'playerAlienMode':
                    // Player toggled alien mode
                    updateOtherPlayerAlienMode(data.playerId, data.isAlienMode, data.planetId);
                    updateActivePlayers(); // Update active players list
                    break;
                    
                case 'bombPlaced':
                    // A player placed a bomb
                    handleOtherPlayerBombPlacement(data);
                    break;
                    
                case 'planetDestroyed':
                    // A planet was destroyed
                    handleOtherPlayerPlanetDestruction(data.planetId);
                    break;
                    
                case 'chat':
                    // Chat message received
                    receiveChatMessage(data);
                    break;
            }
        }
        
        // Create ship model for other players
        function createOtherPlayerShip(playerData) {
            // Create a ship model similar to player ship but simpler
            const shipGroup = new THREE.Group();
            
            // UFO body
            const bodyGeometry = new THREE.SphereGeometry(1, 32, 32);
            bodyGeometry.scale(1, 0.4, 1);
            const bodyMaterial = new THREE.MeshPhongMaterial({ 
                color: playerData.color,
                specular: 0x111111,
                shininess: 100
            });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            shipGroup.add(body);
            
            // Cockpit dome
            const domeGeometry = new THREE.SphereGeometry(0.5, 32, 16, 0, Math.PI * 2, 0, Math.PI / 2);
            const domeMaterial = new THREE.MeshPhongMaterial({
                color: 0x44aaff,
                specular: 0xffffff,
                shininess: 100,
                transparent: true,
                opacity: 0.9
            });
            const dome = new THREE.Mesh(domeGeometry, domeMaterial);
            dome.position.y = 0.2;
            shipGroup.add(dome);
            
            // Add a light to the ship
            const shipLight = new THREE.PointLight(playerData.color, 0.5, 30);
            shipGroup.add(shipLight);
            
            // Add player ID text above ship
            const textCanvas = document.createElement('canvas');
            textCanvas.width = 256;
            textCanvas.height = 64;
            const textContext = textCanvas.getContext('2d');
            textContext.font = 'Bold 24px Arial';
            textContext.fillStyle = playerData.color;
            textContext.textAlign = 'center';
            textContext.fillText(playerData.id, 128, 32);
            
            const textTexture = new THREE.CanvasTexture(textCanvas);
            const textMaterial = new THREE.SpriteMaterial({ map: textTexture });
            const textSprite = new THREE.Sprite(textMaterial);
            textSprite.scale.set(5, 1.25, 1);
            textSprite.position.y = 2;
            shipGroup.add(textSprite);
            
            // Set initial position and rotation
            shipGroup.position.set(
                playerData.position.x,
                playerData.position.y,
                playerData.position.z
            );
            
            if (playerData.rotation) {
                shipGroup.rotation.set(
                    playerData.rotation.x,
                    playerData.rotation.y,
                    playerData.rotation.z
                );
            }
            
            // Add to scene
            scene.add(shipGroup);
            
            // Create alien model if in alien mode
            let alienModel = null;
            if (playerData.isAlienMode) {
                alienModel = createOtherPlayerAlien(playerData);
            }
            
            // Store player data
            gameState.multiplayer.otherPlayers.set(playerData.id, {
                id: playerData.id,
                model: shipGroup,
                alienModel: alienModel,
                color: playerData.color,
                isAlienMode: playerData.isAlienMode,
                landedPlanetId: playerData.landedPlanetId
            });
        }
        
        // Create alien model for other players
        function createOtherPlayerAlien(playerData) {
            // Create a simple alien model (similar to player alien but simpler)
            const alienGroup = new THREE.Group();
            
            // Head
            const headGeometry = new THREE.SphereGeometry(0.2, 16, 16);
            headGeometry.scale(0.8, 1.2, 1);
            const headMaterial = new THREE.MeshLambertMaterial({ color: playerData.color });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.y = 0.6;
            alienGroup.add(head);
            
            // Body
            const bodyGeometry = new THREE.CylinderGeometry(0.15, 0.1, 0.4, 16);
            const bodyMaterial = new THREE.MeshLambertMaterial({ color: playerData.color });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = 0.3;
            alienGroup.add(body);
            
            // Add a small light
            const alienLight = new THREE.PointLight(playerData.color, 0.5, 10);
            alienLight.position.set(0, 0.5, 0);
            alienGroup.add(alienLight);
            
            // Position alien near the landed planet
            if (playerData.landedPlanetId) {
                const planet = gameState.planets.find(p => p.id === playerData.landedPlanetId);
                if (planet) {
                    const planetPosition = new THREE.Vector3();
                    planet.group.getWorldPosition(planetPosition);
                    
                    // Position on planet surface
                    alienGroup.position.copy(planetPosition);
                    alienGroup.position.normalize();
                    alienGroup.position.multiplyScalar(planet.size + 1);
                }
            }
            
            // Add alien to scene
            scene.add(alienGroup);
            
            return alienGroup;
        }
        
        // Remove other player ship
        function removeOtherPlayerShip(playerId) {
            const player = gameState.multiplayer.otherPlayers.get(playerId);
            if (player) {
                scene.remove(player.model);
                if (player.alienModel) {
                    scene.remove(player.alienModel);
                }
                gameState.multiplayer.otherPlayers.delete(playerId);
            }
        }
        
        // Update other players positions
        function updateOtherPlayersPositions(playersData) {
            Object.values(playersData).forEach(playerData => {
                // Skip our own player
                if (playerData.id === gameState.multiplayer.playerId) return;
                
                const player = gameState.multiplayer.otherPlayers.get(playerData.id);
                
                // If player doesn't exist yet, create them
                if (!player) {
                    createOtherPlayerShip(playerData);
                    return;
                }
                
                // Update position and rotation
                if (!player.isAlienMode) {
                    // Update ship position with smooth interpolation
                    player.model.position.lerp(
                        new THREE.Vector3(
                            playerData.position.x,
                            playerData.position.y,
                            playerData.position.z
                        ),
                        0.2
                    );
                    
                    // Update rotation
                    if (playerData.rotation) {
                        player.model.rotation.set(
                            playerData.rotation.x,
                            playerData.rotation.y,
                            playerData.rotation.z
                        );
                    }
                } else if (player.alienModel) {
                    // Update alien position if in alien mode
                    player.alienModel.position.lerp(
                        new THREE.Vector3(
                            playerData.position.x,
                            playerData.position.y,
                            playerData.position.z
                        ),
                        0.2
                    );
                }
            });
        }
        
        // Toggle alien mode for other player
        function updateOtherPlayerAlienMode(playerId, isAlienMode, planetId) {
            const player = gameState.multiplayer.otherPlayers.get(playerId);
            if (!player) return;
            
            player.isAlienMode = isAlienMode;
            player.landedPlanetId = planetId;
            
            // Toggle visibility of ship and alien
            player.model.visible = !isAlienMode;
            
            if (isAlienMode) {
                // Create alien model if it doesn't exist
                if (!player.alienModel) {
                    player.alienModel = createOtherPlayerAlien({
                        id: playerId,
                        color: player.color,
                        landedPlanetId: planetId
                    });
                } else {
                    player.alienModel.visible = true;
                }
            } else if (player.alienModel) {
                player.alienModel.visible = false;
            }
        }
        
        // Handle bomb placement by other player
        function handleOtherPlayerBombPlacement(data) {
            // Find the planet
            const planet = gameState.planets.find(p => p.id === data.planetId);
            if (!planet) return;
            
            // Create bomb at position
            const bomb = createBomb(new THREE.Vector3(
                data.position.x,
                data.position.y,
                data.position.z
            ));
            
            // Set bomb countdown
            bomb.countdown = data.countdown;
            
            // Mark planet as having a bomb
            planet.hasBomb = true;
            planet.bombCountdown = data.countdown;
            
            // Show message
            showMessage(`PLAYER ${data.playerId} PLACED A BOMB ON ${planet.name}`, 3000);
        }
        
        // Handle planet destruction by other player
        function handleOtherPlayerPlanetDestruction(planetId) {
            // Find the planet
            const planet = gameState.planets.find(p => p.id === planetId);
            if (!planet || planet.isDestroyed) return;
            
            // Destroy the planet
            destroyPlanet(planet);
            
            // Show message about who destroyed it
            showMessage(`PLANET ${planet.name} DESTROYED BY ANOTHER PLAYER`, 3000);
        }
        
        // Update player ship color
        function updatePlayerShipColor(color) {
            if (!gameState.playerShip) return;
            
            // Find the ship body and update its material
            gameState.playerShip.traverse((child) => {
                if (child instanceof THREE.Mesh && child.geometry instanceof THREE.SphereGeometry) {
                    child.material.color.set(color);
                }
            });
        }
        
        // Send position update to server
        function sendPositionUpdate() {
            if (!gameState.multiplayer.enabled || !gameState.multiplayer.socket) return;
            
            // Check if it's time to send an update
            const now = Date.now();
            if (now - gameState.multiplayer.lastPositionUpdate < gameState.multiplayer.updateInterval) {
                return;
            }
            gameState.multiplayer.lastPositionUpdate = now;
            
            // Get player position and rotation
            const position = {
                x: gameState.playerShip.position.x,
                y: gameState.playerShip.position.y,
                z: gameState.playerShip.position.z
            };
            
            const rotation = {
                x: gameState.playerShip.rotation.x,
                y: gameState.playerShip.rotation.y,
                z: gameState.playerShip.rotation.z
            };
            
            // Send to server
            sendToServer({
                type: 'updatePosition',
                position,
                rotation
            });
        }
        
        // Send alien mode update to server
        function sendAlienModeUpdate(isAlienMode, planetId = null) {
            if (!gameState.multiplayer.enabled || !gameState.multiplayer.socket) return;
            
            sendToServer({
                type: 'alienMode',
                isAlienMode,
                planetId
            });
        }
        
        // Send bomb placement to server
        function sendBombPlacement(planetId, position) {
            if (!gameState.multiplayer.enabled || !gameState.multiplayer.socket) return;
            
            sendToServer({
                type: 'placeBomb',
                planetId,
                position: {
                    x: position.x,
                    y: position.y,
                    z: position.z
                },
                countdown: 10
            });
        }
        
        // Send planet destruction to server
        function sendPlanetDestruction(planetId) {
            if (!gameState.multiplayer.enabled || !gameState.multiplayer.socket) return;
            
            sendToServer({
                type: 'planetDestroyed',
                planetId
            });
        }
        
        // Send chat message to server
        function sendChatMessage(message) {
            if (!gameState.multiplayer.enabled || !gameState.multiplayer.socket) return;
            
            sendToServer({
                type: 'chat',
                message
            });
        }
        
        // Send data to server
        function sendToServer(data) {
            if (gameState.multiplayer.socket && gameState.multiplayer.socket.readyState === WebSocket.OPEN) {
                gameState.multiplayer.socket.send(JSON.stringify(data));
            }
        }
        
        // Function to update active players list
        function updateActivePlayers() {
            // Get or create the active players container
            let activePlayersContainer = document.getElementById('active-players');
            if (!activePlayersContainer) return;
            
            // Clear previous content
            activePlayersContainer.innerHTML = '<h3 style="margin-top: 0; text-align: center;">ACTIVE PILOTS</h3>';
            
            // Add current player
            if (gameState.multiplayer.enabled && gameState.multiplayer.playerId) {
                const playerElement = document.createElement('div');
                playerElement.style.display = 'flex';
                playerElement.style.alignItems = 'center';
                playerElement.style.marginBottom = '5px';
                
                const colorIndicator = document.createElement('span');
                colorIndicator.style.display = 'inline-block';
                colorIndicator.style.width = '12px';
                colorIndicator.style.height = '12px';
                colorIndicator.style.backgroundColor = gameState.multiplayer.playerColor;
                colorIndicator.style.marginRight = '5px';
                colorIndicator.style.borderRadius = '50%';
                
                const nameElement = document.createElement('span');
                nameElement.textContent = `${gameState.multiplayer.playerId} (YOU)`;
                
                playerElement.appendChild(colorIndicator);
                playerElement.appendChild(nameElement);
                activePlayersContainer.appendChild(playerElement);
                
                // Add other players
                gameState.multiplayer.otherPlayers.forEach(player => {
                    const playerElement = document.createElement('div');
                    playerElement.style.display = 'flex';
                    playerElement.style.alignItems = 'center';
                    playerElement.style.marginBottom = '5px';
                    
                    const colorIndicator = document.createElement('span');
                    colorIndicator.style.display = 'inline-block';
                    colorIndicator.style.width = '12px';
                    colorIndicator.style.height = '12px';
                    colorIndicator.style.backgroundColor = player.color;
                    colorIndicator.style.marginRight = '5px';
                    colorIndicator.style.borderRadius = '50%';
                    
                    const nameElement = document.createElement('span');
                    nameElement.textContent = player.id;
                    
                    // Add alien indicator if player is in alien mode
                    if (player.isAlienMode) {
                        nameElement.textContent += ' (LANDED)';
                    }
                    
                    playerElement.appendChild(colorIndicator);
                    playerElement.appendChild(nameElement);
                    activePlayersContainer.appendChild(playerElement);
                });
            } else {
                const noPlayersElement = document.createElement('div');
                noPlayersElement.textContent = 'MULTIPLAYER DISABLED';
                noPlayersElement.style.textAlign = 'center';
                noPlayersElement.style.color = '#777';
                noPlayersElement.style.fontStyle = 'italic';
                activePlayersContainer.appendChild(noPlayersElement);
            }
        }
        
        // Remove chat interface function since we're now using static HTML elements
        function addChatInterface() {
            // The chat interface elements are now created in HTML
            // We just need to make sure they're visible
            const chatContainer = document.getElementById('chat-container');
            if (chatContainer) {
                chatContainer.style.display = 'flex';
            }
            
            // Initialize chat form event handler
            const chatForm = document.getElementById('chat-form');
            const chatInput = document.getElementById('chat-input');
            
            if (chatForm && chatInput) {
                // Remove any existing handlers (to prevent duplicates)
                const newChatForm = chatForm.cloneNode(true);
                chatForm.parentNode.replaceChild(newChatForm, chatForm);
                
                // Add form submit handler
                newChatForm.addEventListener('submit', (e) => {
                    e.preventDefault();
                    const message = chatInput.value.trim();
                    if (message) {
                        sendChatMessage(message);
                        chatInput.value = '';
                    }
                });
            }
            
            // Clear existing messages
            const chatMessages = document.getElementById('chat-messages');
            if (chatMessages) {
                chatMessages.innerHTML = '';
            }
            
            // Update active players list
            updateActivePlayers();
        }
        
        // Modify removeChatInterface function
        function removeChatInterface() {
            // Hide chat container instead of removing it
            const chatContainer = document.getElementById('chat-container');
            if (chatContainer) {
                chatContainer.style.display = 'none';
            }
            
            // Update active players list
            updateActivePlayers();
        }
        
        // Receive and display chat message
        function receiveChatMessage(data) {
            const chatMessages = document.getElementById('chat-messages');
            if (!chatMessages) return;
            
            // Create message element
            const messageElement = document.createElement('div');
            messageElement.style.marginBottom = '5px';
            
            // Create sender element
            const senderElement = document.createElement('span');
            senderElement.textContent = `${data.playerId}: `;
            senderElement.style.color = data.playerColor;
            senderElement.style.fontWeight = 'bold';
            
            // Create message text element
            const textElement = document.createElement('span');
            textElement.textContent = data.message;
            
            // Add elements to message
            messageElement.appendChild(senderElement);
            messageElement.appendChild(textElement);
            
            // Add message to chat
            chatMessages.appendChild(messageElement);
            
            // Scroll to bottom
            chatMessages.scrollTop = chatMessages.scrollHeight;
            
            // Store message in history
            gameState.multiplayer.chatMessages.push({
                playerId: data.playerId,
                playerColor: data.playerColor,
                message: data.message,
                timestamp: Date.now()
            });
            
            // Limit history to 50 messages
            if (gameState.multiplayer.chatMessages.length > 50) {
                gameState.multiplayer.chatMessages.shift();
            }
        }
        
        // Add player markers to minimap
        function addPlayerMarkersToMinimap() {
            // This function is called inside your updateMinimap() function
            
            // Get player position
            const playerPosition = new THREE.Vector3();
            gameState.playerShip.getWorldPosition(playerPosition);
            
            // Calculate minimap scale - show objects within 20000 units
            const minimapRadius = 20000;
            const minimapSize = 200; // Size of minimap in pixels
            const minimapScale = minimapSize / (minimapRadius * 2);
            
            // Add other players to minimap
            gameState.multiplayer.otherPlayers.forEach((player) => {
                // Skip if player is in alien mode (would clutter the map)
                if (player.isAlienMode) return;
                
                // Get player position
                const otherPlayerPosition = new THREE.Vector3();
                player.model.getWorldPosition(otherPlayerPosition);
                
                // Calculate relative position
                const relativePosition = {
                    x: otherPlayerPosition.x - playerPosition.x,
                    z: otherPlayerPosition.z - playerPosition.z
                };
                
                // Skip if outside minimap radius
                const distance = Math.sqrt(relativePosition.x * relativePosition.x + relativePosition.z * relativePosition.z);
                if (distance > minimapRadius) return;
                
                // Calculate minimap coordinates
                const minimapX = 50 + (relativePosition.x * minimapScale);
                const minimapY = 50 + (relativePosition.z * minimapScale);
                
                // Create player dot
                const playerDot = document.createElement('div');
                playerDot.className = 'minimap-dot';
                playerDot.style.left = minimapX + '%';
                playerDot.style.top = minimapY + '%';
                playerDot.style.backgroundColor = player.color;
                playerDot.style.boxShadow = `0 0 3px ${player.color}`;
                
                // Make dot slightly larger than planets
                playerDot.style.width = '6px';
                playerDot.style.height = '6px';
                
                document.getElementById('minimap-dots').appendChild(playerDot);
            });
        }
        
        // Add a multiplayer toggle button
        function addMultiplayerToggle() {
            const button = document.createElement('button');
            button.id = 'multiplayer-toggle';
            button.textContent = 'ENABLE MULTIPLAYER';
            button.style.position = 'absolute';
            button.style.top = '230px';
            button.style.right = '20px';
            button.style.padding = '10px';
            button.style.backgroundColor = 'rgba(0, 0, 0, 0.5)';
            button.style.color = '#0ff';
            button.style.border = '1px solid #0ff';
            button.style.borderRadius = '10px';
            button.style.cursor = 'pointer';
            button.style.pointerEvents = 'auto';
            
            // Add a debounce mechanism to prevent rapid toggling
            let lastClickTime = 0;
            
            button.addEventListener('click', () => {
                try {
                    // Debounce clicks to prevent rapid toggling which can cause issues
                    const now = Date.now();
                    if (now - lastClickTime < 2000) {
                        console.log('Toggling too quickly, ignoring click');
                        return;
                    }
                    lastClickTime = now;
                    
                    if (gameState.multiplayer.enabled) {
                        // Disable multiplayer with explicit user intention flag
                        disableMultiplayer(true);
                    } else {
                        // Show connecting status
                        button.textContent = 'CONNECTING...';
                        button.disabled = true; // Prevent additional clicks during connection
                        
                        // Enable multiplayer
                        initMultiplayer();
                        
                        // Reset button state after a delay
                        setTimeout(() => {
                            button.disabled = false;
                            button.textContent = gameState.multiplayer.enabled ? 
                                'DISABLE MULTIPLAYER' : 'ENABLE MULTIPLAYER';
                        }, 3000);
                    }
                } catch (error) {
                    console.error("Error toggling multiplayer:", error);
                    button.disabled = false;
                    button.textContent = 'ENABLE MULTIPLAYER';
                }
            });
            
            document.getElementById('ui-container').appendChild(button);
        }
        
        // Update alien symbols panel
        function updateAlienSymbols() {
            const panel = document.getElementById('alien-symbols');
            panel.innerHTML = '';
            
            gameState.discoveredMessages.forEach(message => {
                const span = document.createElement('span');
                span.textContent = message.symbol;
                span.style.cursor = 'pointer';
                span.style.opacity = message.discovered ? '1.0' : '0.5';
                
                // Add tooltip with meaning if discovered
                if (message.discovered) {
                    span.title = message.meaning;
                    span.style.color = '#0ff';
                }
                
                span.addEventListener('click', () => {
                    if (message.discovered) {
                        showMessage(message.meaning, 2000);
                    } else {
                        showMessage("UNKNOWN SYMBOL - TRANSLATION NEEDED", 2000);
                    }
                });
                
                panel.appendChild(span);
            });
        }
        
        // Discover a new alien symbol
        function discoverSymbol(symbolIndex) {
            if (!gameState.discoveredMessages[symbolIndex].discovered) {
                gameState.discoveredMessages[symbolIndex].discovered = true;
                updateAlienSymbols();
                showMessage(`NEW ALIEN SYMBOL TRANSLATED: ${gameState.discoveredMessages[symbolIndex].meaning}`, 3000);
            }
        }
        
        // Main animation loop
        function animate() {
            // Exit if page is not visible
            if (document.hidden) return;
            
            // Request next frame
            requestAnimationFrame(animate);
            
            // Handle loading screen
            if (gameState.isLoading) {
                updateLoading();
                return;
            }
            
            // Get delta time
            const delta = clock.getDelta();
            
            // Update controls
            if (gameState.isAlienMode) {
                updateAlienControls(delta);
            } else {
                updateShipControls(delta);
                
                // Send position updates if in multiplayer mode
                if (gameState.multiplayer.enabled && !gameState.isAlienMode) {
                    sendPositionUpdate();
                }
            }
            
            // Update bombs
            updateBombs(delta);
            
            // Update explosions and particles
            updateExplosions(delta);
            
            // Update debris
            updateDebris(delta);
            
            // Update planets
            updatePlanets(delta);
            
            // Update nearest planet
            updateNearestPlanet();
            
            // Check and generate planets as needed
            checkAndGeneratePlanets();
            
            // Update tractor beam
            updateTractorBeam();
            
            // Update wormholes
            updateWormholes(delta);
            
            // Check wormhole proximity
            checkWormholeProximity();
            
            // Update minimap
            updateMinimap();
            
            // Render the current scene (either main scene or flat scene)
            renderer.render(gameState.currentScene, gameState.camera);
        }
        
        function updateLoading() {
            // Simulate loading progress
            gameState.loadingProgress += 0.5;
            document.getElementById('loading-bar').style.width = Math.min(100, gameState.loadingProgress) + '%';
            
            // Complete loading
            if (gameState.loadingProgress >= 100) {
                gameState.isLoading = false;
                document.getElementById('loading-screen').style.display = 'none';
                document.getElementById('tutorial').classList.remove('hidden');
                gameState.isTutorialVisible = true;
            }
        }
        
        // Initialize game
        function init() {
            // Initialize Three.js
            initThreeJS();
            
            // Set scene reference in gameState for easier access
            gameState.mainScene = scene;
            gameState.currentScene = scene;
            
            // Setup lighting
            initLighting();
            
            // Create starfield
            createStarfield();
            
            // Create player ship
            createPlayerShip();
            
            // Create alien
            createAlien();
            
            // Create planets
            createInitialPlanets();
            
            // Create a test wormhole
            createWormhole(new THREE.Vector3(500, 0, -1000), 30);
            
            // Setup input handlers
            setupInputHandlers();
            
            // Initialize minimap event listener for navigation
            document.getElementById('minimap').addEventListener('click', function(event) {
                // Get click position relative to minimap center
                const rect = this.getBoundingClientRect();
                const x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
                const y = ((event.clientY - rect.top) / rect.height) * 2 - 1;
                
                // Calculate destination based on minimap scale
                const minimapRadius = 20000;
                const playerPosition = new THREE.Vector3();
                gameState.playerShip.getWorldPosition(playerPosition);
                
                // Set navigation target
                const targetX = playerPosition.x + (x * minimapRadius);
                const targetZ = playerPosition.z + (y * minimapRadius);
                
                showMessage(`NAVIGATION TARGET SET: ${Math.floor(targetX)}, ${Math.floor(targetZ)}`, 2000);
                
                // Optional: Add navigation assist arrow pointing to destination
                gameState.navigationTarget = new THREE.Vector3(targetX, playerPosition.y, targetZ);
            });
            
            // Add multiplayer toggle button
            addMultiplayerToggle();
            
            // Initialize alien symbols
            updateAlienSymbols();
            
            // Initialize active players list
            updateActivePlayers();
            
            // Initialize tutorial events
            initializeTutorialEvents();
            
            // Initialize widget states
            initWidgetStates();
            
            // Start animation loop
            animate();
        }
        
        init();
        
        // Close tutorial button function
        window.hideTutorial = hideTutorial;
        
        // Widget visibility toggle function
        window.toggleWidget = toggleWidget;
        window.toggleAllWidgets = toggleAllWidgets;
        
        function toggleWidget(widgetId) {
            const widget = document.getElementById(widgetId);
            if (widget) {
                widget.classList.toggle('minimized');
                
                // Save widget state to localStorage
                const isMinimized = widget.classList.contains('minimized');
                localStorage.setItem(`${widgetId}-minimized`, isMinimized);
            }
        }
        
        function toggleAllWidgets() {
            const widgets = ['hud', 'planet-info', 'instructions'];
            const toggleButton = document.getElementById('toggle-all-widgets');
            const toggleIcon = toggleButton ? toggleButton.querySelector('.toggle-icon') : null;
            
            // Check if all widgets are minimized
            const allMinimized = widgets.every(id => {
                const widget = document.getElementById(id);
                return widget && widget.classList.contains('minimized');
            });
            
            // Toggle all widgets
            widgets.forEach(widgetId => {
                const widget = document.getElementById(widgetId);
                if (widget) {
                    // If all are minimized, expand all; otherwise minimize all
                    if (allMinimized) {
                        widget.classList.remove('minimized');
                        if (toggleIcon) toggleIcon.textContent = 'üîΩ';
                    } else {
                        widget.classList.add('minimized');
                        if (toggleIcon) toggleIcon.textContent = 'üîº';
                    }
                    
                    // Save widget state
                    localStorage.setItem(`${widgetId}-minimized`, !allMinimized);
                }
            });
        }
        
        // Initialize widget states from localStorage
        function initWidgetStates() {
            const widgets = ['hud', 'planet-info', 'instructions'];
            const isMobile = window.innerWidth <= 768 || /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
            
            widgets.forEach(widgetId => {
                const widget = document.getElementById(widgetId);
                if (widget) {
                    // Get saved state
                    let isMinimized = localStorage.getItem(`${widgetId}-minimized`) === 'true';
                    
                    // On mobile, default certain widgets to minimized if no saved state
                    if (isMobile && localStorage.getItem(`${widgetId}-minimized`) === null) {
                        if (widgetId === 'instructions' || widgetId === 'planet-info') {
                            isMinimized = true;
                        }
                    }
                    
                    // Apply state
                    if (isMinimized) {
                        widget.classList.add('minimized');
                    }
                }
            });
            
            // Set toggle-all button initial state
            const toggleButton = document.getElementById('toggle-all-widgets');
            if (toggleButton) {
                const toggleIcon = toggleButton.querySelector('.toggle-icon');
                const allMinimized = widgets.every(id => {
                    const widget = document.getElementById(id);
                    return widget && widget.classList.contains('minimized');
                });
                
                if (toggleIcon) {
                    toggleIcon.textContent = allMinimized ? 'üîº' : 'üîΩ';
                }
            }
        }
        
        // Tutorial auto-close timer
        let tutorialTimerId = null;
        
        function hideTutorial() {
            document.getElementById('tutorial').classList.add('hidden');
            gameState.isTutorialVisible = false;
            
            // Clear the auto-close timer if it exists
            if (tutorialTimerId) {
                clearTimeout(tutorialTimerId);
                tutorialTimerId = null;
            }
        }
        
        // Initialize tutorial touch events
        function initializeTutorialEvents() {
            const tutorial = document.getElementById('tutorial');
            
            // Add keyboard escape key handler
            document.addEventListener('keydown', function(e) {
                if (e.key === 'Escape' && gameState.isTutorialVisible) {
                    hideTutorial();
                }
            });
            
            // Make sure mobile devices can see the close button
            if ('ontouchstart' in window) {
                // Add extra close buttons for mobile
                const closeButton = document.getElementById('tutorial-close');
                if (closeButton) {
                    closeButton.style.fontSize = '20px';
                    closeButton.style.padding = '20px 0';
                }
                
                // Set tutorial content max-height to ensure button visibility
                const tutorialContent = tutorial.querySelector('ul');
                if (tutorialContent) {
                    tutorialContent.style.maxHeight = '50vh';
                    tutorialContent.style.overflowY = 'auto';
                }
                
                // Add handler for orientation changes
                window.addEventListener('resize', adjustTutorialForMobile);
                window.addEventListener('orientationchange', function() {
                    // Some devices need a slight delay after orientation change
                    setTimeout(adjustTutorialForMobile, 300);
                });
                
                // Initial adjustment
                adjustTutorialForMobile();
            }
            
            // Add countdown timer element to tutorial
            const timerElement = document.createElement('div');
            timerElement.id = 'tutorial-timer';
            timerElement.style.position = 'absolute';
            timerElement.style.top = '10px';
            timerElement.style.left = '10px';
            timerElement.style.color = '#ffffff';
            timerElement.style.fontSize = '18px';
            timerElement.style.fontWeight = 'bold';
            timerElement.style.backgroundColor = 'rgba(0, 0, 0, 0.6)';
            timerElement.style.padding = '5px 10px';
            timerElement.style.borderRadius = '5px';
            timerElement.style.border = '1px solid #0ff';
            timerElement.style.textShadow = '0 0 5px #0ff';
            timerElement.style.zIndex = '15';
            timerElement.textContent = 'Auto-close: 10s';
            
            // Insert timer before the X button
            const tutorialHeader = tutorial.querySelector('.tutorial-header');
            if (tutorialHeader) {
                tutorialHeader.appendChild(timerElement);
            } else {
                tutorial.insertBefore(timerElement, tutorial.firstChild);
            }
            
            // Start auto-close timer (10 seconds)
            startTutorialAutoCloseTimer();
        }
        
        // Function to start the tutorial auto-close timer
        function startTutorialAutoCloseTimer() {
            // Clear any existing timer
            if (tutorialTimerId) {
                clearTimeout(tutorialTimerId);
            }
            
            let timeLeft = 10;
            const timerElement = document.getElementById('tutorial-timer');
            
            // Update timer display every second
            const updateTimer = () => {
                timeLeft--;
                if (timerElement) {
                    timerElement.textContent = `Auto-close: ${timeLeft}s`;
                }
                
                if (timeLeft > 0) {
                    tutorialTimerId = setTimeout(updateTimer, 1000);
                } else {
                    hideTutorial();
                }
            };
            
            // Start countdown
            tutorialTimerId = setTimeout(updateTimer, 1000);
        }
        
        // Adjust tutorial for mobile screens
        function adjustTutorialForMobile() {
            const tutorial = document.getElementById('tutorial');
            const closeButton = document.getElementById('tutorial-close');
            
            if (!tutorial || !closeButton) return;
            
            // Check if we're in portrait or landscape
            const isPortrait = window.innerHeight > window.innerWidth;
            
            if (isPortrait) {
                // Portrait mode - make tutorial taller but ensure button is visible
                tutorial.style.maxHeight = '70vh';
                closeButton.style.position = 'fixed';
                closeButton.style.bottom = '20px';
                closeButton.style.left = '50%';
                closeButton.style.transform = 'translateX(-50%)';
                closeButton.style.width = '80%';
                closeButton.style.zIndex = '501';
            } else {
                // Landscape mode - make button part of the scrollable content
                tutorial.style.maxHeight = '80vh';
                closeButton.style.position = 'sticky';
                closeButton.style.bottom = '0';
                closeButton.style.left = 'auto';
                closeButton.style.transform = 'none';
                closeButton.style.width = '100%';
            }
        }
        
        function showAlienReturnAnimation() {
            // Show return message
            showMessage("RETURNING TO SHIP CONTROLS", 2000);
        }
        
        function updateExplosions(delta) {
            // Update existing particles from explosions
            updateParticles(delta);
            
            // Update any active explosion effects
            for (let i = 0; i < gameState.explosions?.length || 0; i++) {
                const explosion = gameState.explosions[i];
                
                // Update lifetime
                explosion.life -= delta;
                
                // Fade out light intensity
                if (explosion.light) {
                    explosion.light.intensity = Math.max(0, explosion.light.intensity * 0.95);
                }
                
                // Remove if expired
                if (explosion.life <= 0) {
                    scene.remove(explosion.group);
                    gameState.explosions.splice(i, 1);
                    i--;
                }
            }
        }
        
        // Function to disconnect from multiplayer
        function disableMultiplayer(userIntent = false) {
            if (!gameState.multiplayer.enabled) return;
            
            // Close socket connection if it exists
            if (gameState.multiplayer.socket && gameState.multiplayer.socket.readyState === WebSocket.OPEN) {
                gameState.multiplayer.socket.close();
            }
            
            // Update game state
            gameState.multiplayer.enabled = false;
            gameState.multiplayer.socket = null;
            
            // Remove other players from scene
            gameState.multiplayer.otherPlayers.forEach(player => {
                scene.remove(player.model);
                if (player.alienModel) {
                    scene.remove(player.alienModel);
                }
            });
            
            // Clear other players map
            gameState.multiplayer.otherPlayers.clear();
            
            // Hide chat interface
            const chatContainer = document.getElementById('chat-container');
            if (chatContainer) {
                chatContainer.style.display = 'none';
            }
            
            // Update active players display
            updateActivePlayers();
            
            // Update button text
            const button = document.getElementById('multiplayer-toggle');
            if (button) {
                button.textContent = 'ENABLE MULTIPLAYER';
            }
            
            // Show message only if intentionally disconnected by the user
            if (userIntent) {
                showMessage('MULTIPLAYER DISABLED', 2000);
            }
        }
    </script>
</body>
</html>

